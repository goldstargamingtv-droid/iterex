<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  
  <!-- Primary Meta Tags -->
  <title>Iterex — AI-Accelerated Web Development Studio</title>
  <meta name="title" content="Iterex — AI-Accelerated Web Development Studio">
  <meta name="description" content="Premium digital experiences crafted through relentless iteration. AI-accelerated web development studio offering templates, browser extensions, and custom development. Iterate. Execute. Ship.">
  <meta name="keywords" content="web development, AI development, web studio, premium templates, browser extensions, custom development, Iterex, web design, frontend development">
  <meta name="author" content="Iterex">
  <meta name="robots" content="index, follow">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://iterex.dev/">
  <meta property="og:title" content="Iterex — AI-Accelerated Web Development Studio">
  <meta property="og:description" content="Premium digital experiences crafted through relentless iteration. Your vision, realized in days—not months.">
  <meta property="og:image" content="https://iterex.dev/og-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:site_name" content="Iterex">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://iterex.dev/">
  <meta name="twitter:title" content="Iterex — AI-Accelerated Web Development Studio">
  <meta name="twitter:description" content="Premium digital experiences crafted through relentless iteration. Your vision, realized in days—not months.">
  <meta name="twitter:image" content="https://iterex.dev/og-image.png">
  
  <!-- Theme Color -->
  <meta name="theme-color" content="#0a0a0f">
  <meta name="msapplication-TileColor" content="#0a0a0f">
  
  <!-- Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "name": "Iterex",
    "url": "https://iterex.dev",
    "logo": "https://iterex.dev/og-image.png",
    "description": "AI-accelerated web development studio",
    "slogan": "Iterate. Execute. Ship."
  }
  </script>
  
  
  <style type="text/css">@font-face {font-family:Syne;font-style:normal;font-weight:400;src:url(/cf-fonts/v/syne/5.0.18/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:400;src:url(/cf-fonts/v/syne/5.0.18/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:400;src:url(/cf-fonts/v/syne/5.0.18/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:500;src:url(/cf-fonts/v/syne/5.0.18/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:500;src:url(/cf-fonts/v/syne/5.0.18/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:500;src:url(/cf-fonts/v/syne/5.0.18/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:600;src:url(/cf-fonts/v/syne/5.0.18/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:600;src:url(/cf-fonts/v/syne/5.0.18/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:600;src:url(/cf-fonts/v/syne/5.0.18/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:700;src:url(/cf-fonts/v/syne/5.0.18/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:700;src:url(/cf-fonts/v/syne/5.0.18/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:700;src:url(/cf-fonts/v/syne/5.0.18/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:800;src:url(/cf-fonts/v/syne/5.0.18/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:800;src:url(/cf-fonts/v/syne/5.0.18/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Syne;font-style:normal;font-weight:800;src:url(/cf-fonts/v/syne/5.0.18/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Space Mono;font-style:normal;font-weight:400;src:url(/cf-fonts/s/space-mono/5.0.18/latin-ext/400/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Space Mono;font-style:normal;font-weight:400;src:url(/cf-fonts/s/space-mono/5.0.18/vietnamese/400/normal.woff2);unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB;font-display:swap;}@font-face {font-family:Space Mono;font-style:normal;font-weight:400;src:url(/cf-fonts/s/space-mono/5.0.18/latin/400/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Space Mono;font-style:normal;font-weight:700;src:url(/cf-fonts/s/space-mono/5.0.18/latin-ext/700/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Space Mono;font-style:normal;font-weight:700;src:url(/cf-fonts/s/space-mono/5.0.18/latin/700/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Space Mono;font-style:normal;font-weight:700;src:url(/cf-fonts/s/space-mono/5.0.18/vietnamese/700/normal.woff2);unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB;font-display:swap;}</style>
  
  <!-- GSAP -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollToPlugin.min.js"></script>
  
  <style>
    /* ═══════════════════════════════════════════════════════════════════
       CRITICAL: First-paint protection - parsed before ANYTHING renders
       Hero DOM content hidden until warp reveals it (no animation, instant show)
       ═══════════════════════════════════════════════════════════════════ */
    .js-loading #hero .panel-content,
    .js-loading #hero .panel-tag,
    .js-loading #hero h1,
    .js-loading #hero p,
    .js-loading #hero .hero-ctas {
      opacity: 0 !important;
      visibility: hidden !important;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --bg: #0a0a0a;
      --white: #ffffff;
      --gray-300: #a0a0a0;
      --gray-500: #606060;
      --gray-700: #2a2a2a;
    }
    
    html, body {
      background: var(--bg);
      color: var(--white);
      font-family: 'Syne', sans-serif;
      overscroll-behavior: none;
      cursor: none;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    
    html::-webkit-scrollbar,
    body::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       CURSOR
    ═══════════════════════════════════════════════════════════════════ */
    
    .cursor {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
      transform: translate(-50%, -50%);
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 14px;
      font-weight: 600;
      color: rgba(150, 150, 150, 0.5);
      transition: transform 0.1s ease, font-size 0.2s ease, color 0.2s ease;
      will-change: transform;
      white-space: nowrap;
    }
    
    .cursor.hover {
      font-size: 18px;
      color: rgba(150, 150, 150, 0.7);
    }
    
    .cursor.clicking {
      transform: translate(-50%, -50%) scale(0.8);
    }
    
    .cursor-trail {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 14px;
      font-weight: 700;
      color: #ffffff;
      text-shadow: 
        0 0 2px #fff,
        0 0 4px #fff,
        0 0 8px #fff,
        0 0 16px #fff,
        0 0 32px rgba(255, 255, 255, 0.8);
      transform: translate(-50%, -50%);
      will-change: transform;
      white-space: nowrap;
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       CANVAS
    ═══════════════════════════════════════════════════════════════════ */
    
    #canvas-container {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       NAV
    ═══════════════════════════════════════════════════════════════════ */
    
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 24px 40px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      mix-blend-mode: difference;
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      opacity: 0;
      filter: blur(10px);
      cursor: none;
    }
    
    .nav-links {
      display: flex;
      gap: 32px;
      opacity: 0;
      filter: blur(10px);
    }
    
    .nav-links a {
      color: var(--gray-300);
      text-decoration: none;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      transition: color 0.3s;
      cursor: none;
    }
    
    .nav-links a:hover {
      color: var(--white);
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       SECTIONS - Each section is 100vh and will be PINNED
    ═══════════════════════════════════════════════════════════════════ */
    
    .panel {
      position: relative;
      width: 100%;
      height: 100vh;
      display: flex;
      align-items: center;
      overflow: hidden;
      z-index: 10;
    }
    
    .panel-content {
      position: relative;
      z-index: 2;
      padding: 0 48px;
      max-width: 550px;
    }
    
    .panel-tag {
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: var(--gray-500);
      margin-bottom: 20px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(30px);
    }
    
    .panel h1, .panel h2 {
      font-size: clamp(36px, 5vw, 56px);
      font-weight: 700;
      line-height: 1.05;
      letter-spacing: -1px;
      margin-bottom: 24px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(50px);
    }
    
    .panel h1 {
      font-size: clamp(48px, 7vw, 72px);
    }
    
    .panel h1 span {
      display: block;
      color: var(--gray-500);
    }
    
    .panel p {
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      font-weight: 500;
      color: #c0c0c0;
      line-height: 1.9;
      max-width: 400px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(40px);
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       HERO CTAs
    ═══════════════════════════════════════════════════════════════════ */
    
    .hero-ctas {
      display: flex;
      gap: 16px;
      margin-top: 32px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(30px);
      position: relative;
      z-index: 10;
    }
    
    .hero-ctas .cta-btn {
      position: relative;
      padding: 14px 28px;
      margin-top: 0;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      text-decoration: none;
      border: none;
      cursor: none;
      pointer-events: auto;
      overflow: hidden;
      opacity: 1;
      transform: none;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .hero-ctas .cta-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    /* Primary CTA - Glassmorphism with holographic border */
    .hero-ctas .cta-primary {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
    }
    
    .hero-ctas .cta-primary::before {
      background: linear-gradient(
        135deg,
        rgba(255, 100, 50, 0.15) 0%,
        rgba(255, 150, 50, 0.15) 50%,
        rgba(255, 80, 80, 0.15) 100%
      );
    }
    
    .hero-ctas .cta-primary::after {
      content: '';
      position: absolute;
      inset: -1px;
      background: linear-gradient(
        135deg,
        rgba(255, 100, 50, 0.5),
        rgba(255, 150, 50, 0.5),
        rgba(255, 80, 80, 0.5),
        rgba(255, 100, 50, 0.5)
      );
      background-size: 300% 300%;
      border-radius: 12px;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
      animation: holoBorder 4s ease infinite;
    }
    
    @keyframes holoBorder {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    .hero-ctas .cta-primary:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 10px 40px rgba(255, 100, 50, 0.2),
        0 0 20px rgba(255, 150, 50, 0.1);
    }
    
    .hero-ctas .cta-primary:hover::before {
      opacity: 1;
    }
    
    .hero-ctas .cta-primary:hover::after {
      opacity: 1;
    }
    
    /* Ghost CTA - Outline only */
    .hero-ctas .cta-ghost {
      background: transparent;
      color: var(--gray-300);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
    }
    
    .hero-ctas .cta-ghost::before {
      background: rgba(255, 255, 255, 0.05);
    }
    
    .hero-ctas .cta-ghost:hover {
      color: #fff;
      border-color: rgba(255, 255, 255, 0.4);
      transform: translateY(-2px);
    }
    
    .hero-ctas .cta-ghost:hover::before {
      opacity: 1;
    }
    
    .hero-ctas .cta-ghost .cta-arrow {
      display: inline-block;
      margin-left: 8px;
      transition: transform 0.3s ease;
    }
    
    .hero-ctas .cta-ghost:hover .cta-arrow {
      transform: translateX(4px);
    }
    
    .about-secondary {
      margin-top: 20px;
      font-size: 11px;
      font-weight: 500;
      color: #999999;
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       FOUNDER CARD
    ═══════════════════════════════════════════════════════════════════ */
    
    .founder-card {
      position: absolute;
      left: 18%;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      z-index: 20;
    }
    
    .founder-image {
      width: 280px;
      height: 280px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 40px rgba(100, 150, 255, 0.15);
    }
    
    .founder-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .founder-info {
      text-align: center;
    }
    
    .founder-name {
      font-family: 'Syne', sans-serif;
      font-size: 16px;
      font-weight: 600;
      color: var(--white);
      letter-spacing: 0.5px;
    }
    
    .founder-title {
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      color: var(--gray-500);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-top: 4px;
    }
    
    .founder-quote {
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      color: var(--gray-300);
      font-style: italic;
      margin-top: 12px;
      white-space: nowrap;
    }
    
    /* Right-aligned panels */
    .panel.right {
      justify-content: flex-end;
    }
    
    .panel.right .panel-content {
      text-align: right;
    }
    
    /* Process section - full height flex layout */
    #templates {
      justify-content: center !important;
      align-items: center !important;
      flex-direction: column !important;
      display: flex !important;
      position: relative;
      overflow: hidden;
    }
    
    /* Process glassmorphic cards - base styling */
    .process-card {
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 24px;
      padding: 36px 40px;
      text-align: left;
      max-width: 340px;
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      z-index: 2;
      opacity: 0;
      visibility: hidden;
    }
    
    /* Left card positioning - same as before */
    .process-card-left {
      left: calc(5% + 150px);
    }
    
    /* Right card positioning - mirrored from left */
    .process-card-right {
      right: calc(5% + 150px);
    }
    
    .process-card .panel-tag {
      margin-bottom: 16px;
    }
    
    .process-card h2 {
      font-size: clamp(28px, 3.5vw, 42px);
      margin-bottom: 20px;
    }
    
    .process-card h3 {
      font-family: 'Syne', sans-serif;
      font-size: clamp(22px, 2.5vw, 32px);
      font-weight: 700;
      margin-bottom: 16px;
      line-height: 1.2;
    }
    
    .process-card p {
      font-size: 13px;
      line-height: 1.7;
      color: var(--gray-300);
    }
    
    /* Process phone area - centered on page with glassmorphism */
    .process-phone-area {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      opacity: 0;
      visibility: hidden;
      /* Glassmorphic styling */
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 24px;
      padding: 12px;
    }
    
    /* Process section GIF */
    .process-gif {
      display: block;
      max-width: 612px;
      border-radius: 12px;
      opacity: 0.9;
    }
    
    /* Process Timeline Steps - horizontal row at bottom */
    .process-steps {
      position: absolute;
      bottom: 12vh;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      padding: 0 10%;
      z-index: 3;
      pointer-events: none;
    }
    
    .process-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transform: translateY(20px);
      width: 140px;
      position: relative;
    }
    
    .step-number {
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      letter-spacing: 3px;
      color: rgba(18, 209, 230, 0.9);
      margin-bottom: 8px;
    }
    
    .step-title {
      font-family: 'Syne', sans-serif;
      font-size: 15px;
      font-weight: 600;
      color: #fff;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    
    .step-desc {
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
      line-height: 1.4;
    }
    
    /* Timeline connecting line container */
    .timeline-line-container {
      position: absolute;
      top: -25px;
      left: calc(10% + 70px);
      right: calc(10% + 70px);
      height: 1px;
      overflow: visible;
    }
    
    /* The animated line that grows */
    .timeline-line {
      position: absolute;
      top: 0;
      left: 0;
      width: 0%;
      height: 1px;
      background: linear-gradient(90deg,
        rgba(18, 209, 230, 0.6) 0%,
        rgba(18, 209, 230, 0.8) 100%
      );
      box-shadow: 0 0 8px rgba(18, 209, 230, 0.4);
    }
    
    /* Step dots on the line - start dim */
    .process-step::before {
      content: '';
      position: absolute;
      top: -29px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background: rgba(18, 209, 230, 0.3);
      border-radius: 50%;
      box-shadow: 0 0 0px rgba(18, 209, 230, 0);
      transition: all 0.4s ease;
    }
    
    /* Glowing dot state */
    .process-step.dot-active::before {
      background: rgba(18, 209, 230, 1);
      box-shadow: 0 0 15px rgba(18, 209, 230, 0.8), 0 0 30px rgba(18, 209, 230, 0.4);
    }
    
    /* About section glassmorphic card */
    #about .panel-content {
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 24px;
      padding: 36px 40px;
      text-align: left;
      max-width: 420px;
      position: absolute;
      right: calc(5% + 150px);
      top: 50%;
      transform: translateY(-50%);
      margin-top: 0px;
      opacity: 0;
      visibility: hidden;
    }
    
    #about .panel-content .panel-tag,
    #about .panel-content h2,
    #about .panel-content p {
      text-align: left;
    }
    
    #about .panel-content h2 {
      font-size: clamp(28px, 3.5vw, 42px);
      margin-bottom: 20px;
    }
    
    #about .panel-content p {
      font-size: 13px;
      line-height: 1.7;
    }
    
    #about .panel-content .about-secondary {
      font-size: 12px;
      margin-top: 16px;
      color: var(--gray-400);
    }
    
    .panel.center {
      justify-content: center;
      text-align: center;
    }
    
    .panel.center .panel-content {
      max-width: 600px;
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       WORK GRID
    ═══════════════════════════════════════════════════════════════════ */
    
    #extensions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 48px;
    }
    
    #extensions .work-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100%;
      width: 100%;
      padding: 100px 40px 40px 40px;
      perspective: 1200px;
    }
    
    #extensions .work-content {
      flex: 0 0 auto;
      text-align: center;
      max-width: 600px;
      margin: 0 auto 20px auto;
      opacity: 0;
      visibility: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    #extensions .work-content .panel-tag,
    #extensions .work-content h2,
    #extensions .work-content p {
      opacity: 0;
      transform: translateY(30px);
      text-align: center;
      width: 100%;
    }
    
    #extensions .work-content p {
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    
    #extensions .work-content h2 {
      font-size: clamp(2rem, 4vw, 3rem);
    }
    
    .work-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 32px;
      max-width: 1400px;
      margin: 0 auto;
      opacity: 0;
      padding: 20px 0 40px 0;
    }
    
    .work-item {
      position: relative;
      aspect-ratio: 1;
      text-decoration: none;
      opacity: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      padding: 40px;
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 32px;
      transition: transform 0.15s ease-out, box-shadow 0.3s ease, border-color 0.3s ease;
      cursor: none;
      overflow: hidden;
      transform-style: preserve-3d;
      will-change: transform;
    }
    
    /* Holographic gradient overlay on hover - Fire/Orange theme */
    .work-item::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(
        135deg,
        rgba(255, 100, 50, 0.15) 0%,
        rgba(255, 150, 50, 0.15) 50%,
        rgba(255, 80, 80, 0.15) 100%
      );
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 32px;
    }
    
    /* Fire border glow - matches Let's Build button */
    .work-item::after {
      content: '';
      position: absolute;
      inset: -1px;
      background: linear-gradient(
        135deg,
        rgba(255, 100, 50, 0.5),
        rgba(255, 150, 50, 0.5),
        rgba(255, 80, 80, 0.5),
        rgba(255, 100, 50, 0.5)
      );
      background-size: 300% 300%;
      border-radius: 33px;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
      animation: holoBorder 4s ease infinite;
    }
    
    .work-item:hover {
      border-color: rgba(255, 255, 255, 0.25);
      box-shadow: 
        0 10px 40px rgba(255, 100, 50, 0.2),
        0 0 20px rgba(255, 150, 50, 0.1);
    }
    
    .work-item:hover::before {
      opacity: 1;
    }
    
    .work-item:hover::after {
      opacity: 1;
    }
    
    /* No stagger needed for flat grid */
    
    .work-logo {
      position: relative;
      z-index: 1;
      width: 140px;
      height: 140px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.4s ease;
    }
    
    .work-logo img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    .work-item:hover .work-logo {
      transform: scale(1.08);
    }
    
    .work-btn {
      position: relative;
      z-index: 1;
      font-family: 'Space Mono', monospace;
      font-size: 13px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255, 255, 255, 0.5);
      transition: color 0.3s ease;
    }
    
    .work-item:hover .work-btn {
      color: #fff;
    }
    
    .work-warning {
      font-family: 'Space Mono', monospace;
      font-size: 8px;
      color: rgba(255, 255, 255, 0.3);
      letter-spacing: 1px;
      margin-top: -8px;
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       CTA BUTTON
    ═══════════════════════════════════════════════════════════════════ */
    
    .cta-btn {
      display: inline-block;
      margin-top: 32px;
      padding: 16px 40px;
      background: var(--white);
      color: var(--bg);
      font-family: 'Syne', sans-serif;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      text-decoration: none;
      opacity: 0;
      transform: translateY(30px);
      transition: transform 0.3s ease;
      cursor: none;
    }
    
    .cta-btn:hover {
      transform: translateY(-2px);
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       CONTACT SECTION - GLASSMORPHIC FORM
    ═══════════════════════════════════════════════════════════════════ */
    
    .contact-glass-bubble {
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 24px;
      padding: 48px 56px;
      margin-bottom: 32px;
      opacity: 0;
      transform: translateY(30px);
      max-width: 480px;
      width: 100%;
    }
    
    .contact-glass-bubble .panel-tag,
    .contact-glass-bubble p {
      color: var(--gray-300);
    }
    
    .contact-glass-bubble h2 {
      color: #fff;
    }
    
    .contact-glass-bubble .panel-tag {
      margin-bottom: 16px;
    }
    
    .contact-glass-bubble h2 {
      margin-bottom: 16px;
    }
    
    .contact-glass-bubble p {
      margin-bottom: 24px;
    }
    
    /* Contact Form Styles */
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .form-row {
      display: flex;
      gap: 16px;
      width: 100%;
    }
    
    .form-row .form-group {
      flex: 1 1 0;
      min-width: 0;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .form-group label {
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: var(--gray-400);
    }
    
    .form-group input,
    .form-group select,
    .form-group textarea {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 14px 16px;
      font-family: 'Syne', sans-serif;
      font-size: 14px;
      color: #fff;
      outline: none;
      transition: border-color 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
      cursor: none;
    }
    
    .form-group input::placeholder,
    .form-group textarea::placeholder {
      color: var(--gray-500);
    }
    
    .form-group select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 16px center;
      padding-right: 40px;
    }
    
    .form-group select option {
      background: #0a0a0f;
      color: #fff;
    }
    
    .form-group textarea {
      min-height: 100px;
      resize: none;
    }
    
    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      border-color: rgba(100, 200, 255, 0.5);
      background: rgba(255, 255, 255, 0.05);
      box-shadow: 
        0 0 20px rgba(100, 200, 255, 0.15),
        0 0 40px rgba(255, 100, 200, 0.1),
        inset 0 0 20px rgba(100, 200, 255, 0.05);
    }
    
    /* Rainbow Submit Button */
    .contact-submit {
      position: relative;
      margin-top: 8px;
      padding: 16px 32px;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      background: rgba(255, 255, 255, 0.06);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      cursor: pointer;
      overflow: hidden;
      transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
    }
    
    .contact-submit::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(
        135deg,
        rgba(255, 50, 100, 0.2) 0%,
        rgba(100, 200, 255, 0.2) 25%,
        rgba(100, 255, 150, 0.2) 50%,
        rgba(255, 200, 50, 0.2) 75%,
        rgba(255, 50, 100, 0.2) 100%
      );
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .contact-submit::after {
      content: '';
      position: absolute;
      inset: -1px;
      background: linear-gradient(
        135deg,
        rgba(255, 50, 100, 0.6),
        rgba(255, 200, 50, 0.6),
        rgba(100, 255, 150, 0.6),
        rgba(100, 200, 255, 0.6),
        rgba(200, 100, 255, 0.6),
        rgba(255, 50, 100, 0.6)
      );
      background-size: 300% 300%;
      border-radius: 12px;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
      animation: rainbowBorder 4s ease infinite;
    }
    
    .contact-submit:hover {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.08);
      box-shadow: 
        0 10px 40px rgba(100, 200, 255, 0.2),
        0 0 20px rgba(255, 100, 200, 0.15),
        0 0 30px rgba(100, 255, 150, 0.1);
    }
    
    .contact-submit:hover::before,
    .contact-submit:hover::after {
      opacity: 1;
    }
    
    .contact-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .contact-submit .btn-text {
      position: relative;
      z-index: 1;
    }
    
    /* Form States */
    .form-success {
      text-align: center;
      padding: 20px 0;
    }
    
    .form-success h3 {
      font-family: 'Syne', sans-serif;
      font-size: 24px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 12px;
    }
    
    .form-success p {
      color: var(--gray-400);
      margin-bottom: 0;
    }
    
    .form-error {
      background: rgba(255, 50, 100, 0.1);
      border: 1px solid rgba(255, 50, 100, 0.3);
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 13px;
      color: rgba(255, 150, 150, 1);
      margin-bottom: 16px;
      display: none;
    }
    
    .form-error.visible {
      display: block;
    }
    
    @keyframes rainbowBorder {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    /* Remove old button styles - keeping for backwards compat */
    .contact-cta-rainbow {
      display: none;
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       PROGRESS INDICATOR
    ═══════════════════════════════════════════════════════════════════ */
    
    .progress {
      position: fixed;
      right: 32px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 12px;
      opacity: 0;
      filter: blur(10px);
    }
    
    .progress-dot {
      width: 8px;
      height: 8px;
      border: 1px solid var(--gray-500);
      border-radius: 50%;
      transition: all 0.4s ease;
      cursor: none;
    }
    
    .progress-dot.active {
      background: var(--white);
      border-color: var(--white);
      transform: scale(1.3);
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       LOADER
    ═══════════════════════════════════════════════════════════════════ */
    
    .loader {
      position: fixed;
      inset: 0;
      background: transparent;
      z-index: 20000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .loader.hidden {
      display: none;
    }
    
    /* Circuit traces - hidden, now drawn in canvas for warp */
    .hud-circuit {
      display: none;
    }
    .hud-tl { top: 0; left: 0; }
    .hud-tr { top: 0; right: 0; }
    .hud-bl { bottom: 0; left: 0; }
    .hud-br { bottom: 0; right: 0; }
    
    /* Center content */
    .loader-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 160px;
    }
    
    /* Loading bar */
    .loader-bar {
      display: none; /* Now drawn in canvas for warp */
    }
    
    .loader-fill {
      height: 100%;
      width: 0%;
      background: rgba(255, 255, 255, 0.7);
      transition: width 0.2s;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
    }
    
    /* Brand with waveform */
    .loader-brand {
      display: none; /* Now drawn in canvas for warp */
    }
    
    .loader-text {
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 10px;
      color: rgba(255, 255, 255, 0.5);
    }
    
    .loader-wave {
      width: 50px;
      height: 16px;
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       RESPONSIVE
    ═══════════════════════════════════════════════════════════════════ */
    
    @media (max-width: 768px) {
      /* Hide desktop-only elements */
      .cursor, .cursor-trail { display: none !important; }
      body { cursor: auto; }
      .corner-bl, .corner-br { display: none; }
      .nav-links { display: none; }
      .progress { 
        /* Move to bottom center on mobile */
        right: auto !important;
        left: 50% !important;
        top: auto !important;
        bottom: 20px !important;
        transform: translateX(-50%) !important;
        flex-direction: row !important;
        gap: 10px !important;
      }
      
      /* ═══════════════════════════════════════════════════════════════
         JUNNI-STYLE: Viewport-based scaling
         Everything scales proportionally with screen width
      ═══════════════════════════════════════════════════════════════ */
      
      /* Root scaling - all rem/em units will scale */
      html {
        font-size: calc(10px + 0.5vw);
      }
      
      /* Typography scales with viewport */
      h1 { font-size: clamp(32px, 10vw, 72px) !important; }
      h2 { font-size: clamp(26px, 8vw, 56px) !important; }
      p { font-size: clamp(11px, 3vw, 16px) !important; line-height: 1.5 !important; }
      .panel-tag { font-size: clamp(8px, 2vw, 11px) !important; }
      
      /* Panels remain full viewport, content scales inside */
      .panel-content {
        padding: 0 5vw !important;
        max-width: 90vw !important;
      }
      
      /* Hero section - center the content block */
      #hero {
        justify-content: center !important;
        align-items: center !important;
      }
      
      #hero .panel-content {
        padding: 0 20px !important;
        text-align: left; /* Keep text left-aligned */
        display: flex;
        flex-direction: column;
        align-items: center; /* Center the block itself */
      }
      
      #hero .panel-tag,
      #hero h1,
      #hero p {
        width: 100%;
        text-align: left;
      }
      
      .hero-ctas {
        flex-direction: column;
        gap: 12px;
        width: 100%;
      }
      
      .hero-ctas .cta-btn {
        padding: 14px 24px !important;
        font-size: 11px !important;
        text-align: center !important; /* Center button text */
        justify-content: center !important;
      }
      
      /* About section - stack vertically, centered on screen */
      #about {
        flex-direction: column !important;
        justify-content: center !important;  /* Center vertically */
        align-items: center !important;
        padding: 60px 0 !important;
      }
      
      .founder-card {
        position: relative !important;
        left: auto !important;
        top: auto !important;
        transform: none !important;
        margin-bottom: 20px;
      }
      
      .founder-image {
        width: 100px !important;
        height: 100px !important;
      }
      
      .founder-name { font-size: 14px !important; }
      .founder-title { font-size: 8px !important; }
      .founder-quote { font-size: 9px !important; }
      
      #about .panel-content {
        position: relative !important;
        right: auto !important;
        left: auto !important;
        top: auto !important;
        transform: none !important;
        max-width: 90vw !important;
        padding: 20px !important;
        text-align: left;
      }
      
      /* Hide secondary paragraph on mobile - too much text */
      #about .about-secondary {
        display: none !important;
      }
      
      /* Work section - centered app-icon grid */
      #extensions {
        justify-content: center !important;
        align-items: center !important;
      }
      
      #extensions .panel-content {
        max-width: 95vw !important;
        text-align: center !important;
      }
      
      .work-container {
        align-items: center !important;
        width: 100% !important;
      }
      
      .work-grid {
        display: grid !important;
        grid-template-columns: repeat(3, 90px) !important;
        gap: 20px 15px !important;
        justify-content: center !important;
        align-items: start !important;
        max-width: 100% !important;
        padding: 10px 0 !important;
      }
      
      .work-item {
        width: 90px !important;
        height: auto !important;
        aspect-ratio: unset !important;
        flex-direction: column !important;
        align-items: center !important;
        padding: 0 !important;
        gap: 8px !important;
        background: none !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        border: none !important;
        border-radius: 0 !important;
      }
      
      .work-item::before,
      .work-item::after {
        display: none !important;
      }
      
      .work-logo {
        width: 90px !important;
        height: 90px !important;
        border-radius: 20px !important;
        overflow: hidden !important;
        background: rgba(255, 255, 255, 0.06) !important;
        backdrop-filter: blur(12px) !important;
        -webkit-backdrop-filter: blur(12px) !important;
        border: 1px solid rgba(255, 255, 255, 0.1) !important;
      }
      
      .work-logo img {
        width: 100% !important;
        height: 100% !important;
        max-width: none !important;
        max-height: none !important;
        object-fit: contain !important;
        padding: 12px !important;
      }
      
      .work-btn {
        font-size: 8px !important;
        letter-spacing: 0.5px !important;
        color: rgba(255, 255, 255, 0.6) !important;
        max-width: 90px !important;
        text-align: center !important;
        white-space: normal !important;
        line-height: 1.3 !important;
      }
      
      .work-warning {
        text-align: center !important;
        width: 100% !important;
        margin-top: 0 !important;
      }
      
      /* Process section cards - match about section glassmorphism exactly */
      .process-card {
        max-width: 90vw !important;
        padding: 20px 24px !important;
        /* Keep same glassmorphism as About - no overrides needed */
      }
      
      .process-card h2 {
        /* Use global h2 size - same as About section */
        margin-bottom: 16px !important;
      }
      
      .process-card p {
        font-size: 13px !important;
        line-height: 1.6 !important;
      }
      
      .process-card .panel-tag {
        margin-bottom: 12px !important;
      }
      
      .process-phone-area {
        transform: scale(0.5);
      }
      
      .process-steps {
        position: absolute !important;
        bottom: 40px !important;
        left: 0 !important;
        right: 0 !important;
        gap: 0 !important;
        padding: 0 5% !important;
        justify-content: space-between !important;
        margin-top: 0 !important;
      }
      
      .process-step {
        min-width: auto !important;
        width: 70px !important;
        position: relative !important;
      }
      
      .step-number { font-size: 9px !important; letter-spacing: 1px !important; }
      .step-title { font-size: 10px !important; }
      .step-desc { display: none !important; }
      
      /* Hide timeline line and dots on mobile */
      .timeline-line-container {
        display: none !important;
      }
      
      .process-step::before {
        display: none !important;
      }
      
      /* Contact section */
      .contact-glass-bubble {
        padding: 24px 20px !important;
        max-width: 90vw !important;
      }
      
      .contact-glass-bubble h2 {
        font-size: clamp(24px, 7vw, 40px) !important;
      }
      
      /* Contact form mobile */
      .form-row {
        flex-direction: column !important;
        gap: 12px !important;
      }
      
      .form-group input,
      .form-group select,
      .form-group textarea {
        font-size: 16px !important; /* Prevents iOS zoom on focus */
        padding: 12px 14px !important;
      }
      
      .contact-submit {
        width: 100% !important;
        padding: 14px 24px !important;
      }
      
      .form-success h3 {
        font-size: 20px !important;
      }
      
      .contact-cta-rainbow {
        display: none !important;
      }
      
      /* Footer */
      .footer-glass-bubble {
        padding: 12px 20px !important;
        flex-wrap: nowrap !important;
        gap: 16px !important;
        width: calc(100% - 40px) !important;
        max-width: none !important;
        bottom: 16px !important;
        border-radius: 16px !important;
      }
      
      .footer-left { gap: 10px !important; }
      .footer-right { gap: 12px !important; }
      .footer-links { gap: 12px !important; }
      .footer-logo { font-size: 12px !important; }
      .footer-copy { font-size: 7px !important; }
      .footer-links span { font-size: 8px !important; }
      
      /* ═══════════════════════════════════════════════════════════════
         ADDITIONAL MOBILE FIXES
      ═══════════════════════════════════════════════════════════════ */
      
      /* Loader - reduce margin to center better on mobile */
      .loader-content {
        margin-top: 80px !important;
      }
      
      /* Process section - stack cards vertically like about section */
      .process-card-left,
      .process-card-right {
        position: relative !important;
        left: auto !important;
        right: auto !important;
        top: auto !important;
        transform: none !important;
        margin: 8px auto !important;
      }
      
      #templates {
        flex-direction: column !important;
        justify-content: flex-start !important;
        align-items: center !important;
        padding-top: 60px !important;
        padding-bottom: 120px !important;
        gap: 8px;
      }
      
      .process-phone-area {
        display: none !important;
      }
      
      /* process-steps positioned at bottom via earlier rule */
    }
    
    /* ═══════════════════════════════════════════════════════════════════
       CORNER ELEMENTS - Subtle tech details
    ═══════════════════════════════════════════════════════════════════ */
    
    .corner-bl {
      position: fixed;
      bottom: 32px;
      left: 40px;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      letter-spacing: 1px;
      color: rgba(255, 255, 255, 0.3);
      z-index: 100;
      opacity: 0;
      filter: blur(10px);
    }
    
    .corner-br {
      position: fixed;
      bottom: 32px;
      right: 40px;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      letter-spacing: 1px;
      color: rgba(255, 255, 255, 0.35);
      z-index: 100;
      text-align: right;
      opacity: 0;
      filter: blur(10px);
    }
    
    .tech-readout {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .tech-row {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
    }
    
    .tech-label {
      color: rgba(255, 255, 255, 0.25);
    }
    
    .tech-value {
      color: rgba(255, 255, 255, 0.5);
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      background: #ff6432;
      border-radius: 50%;
      animation: pulse-dot 2s ease-in-out infinite;
      transition: background 0.8s ease;
    }
    
    .status-dot.ice {
      background: #12d1e6;
    }
    
    .status-dot.rainbow {
      background: linear-gradient(90deg, #ff0000, #ff8000, #ffff00, #00ff00, #00ffff, #0080ff, #8000ff);
      background-size: 600% 100%;
      animation: pulse-dot 2s ease-in-out infinite, rainbow-shift 3s linear infinite;
    }
    
    @keyframes rainbow-shift {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }
    
    @keyframes pulse-dot {
      0%, 100% { opacity: 0.4; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1); }
    }
    
    .tech-line {
      width: 60px;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: scan-line 3s ease-in-out infinite;
    }
    
    @keyframes scan-line {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.7; }
    }
    
    /* Footer Glass Bubble */
    .footer-glass-bubble {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(80px);
      opacity: 0;
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 24px;
      padding: 16px 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 48px;
      z-index: 1000;
      transition: opacity 0.4s ease, transform 0.4s ease;
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    }
    
    .footer-glass-bubble.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    .footer-glass-bubble .footer-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .footer-glass-bubble .footer-logo {
      font-family: 'Syne', sans-serif;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.1em;
    }
    
    .footer-glass-bubble .footer-copy {
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
    }
    
    .footer-glass-bubble .footer-right {
      display: flex;
      align-items: center;
      gap: 24px;
    }
    
    .footer-glass-bubble .footer-links {
      display: flex;
      gap: 24px;
    }
    
    .footer-glass-bubble .footer-links span {
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
    }
  </style>
  <script>
    // Immediate scroll lock - runs before body renders
    document.documentElement.style.overflow = 'hidden';
    document.addEventListener('DOMContentLoaded', () => {
      // Prevent browser from restoring scroll position
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
      window.scrollTo(0, 0);
      
      document.body.style.overflow = 'hidden';
      // Hero hiding now handled entirely by .js-loading class in CSS
    });
  </script>
</head>
<body class="js-loading">
  
  <!-- LOADER - HUD with extending circuit traces from corners -->
  <div class="loader">
    <!-- TOP LEFT - Long extending circuit -->
    <svg class="hud-circuit hud-tl" viewBox="0 0 300 300" fill="none">
      <path d="M0 40 L40 40 L60 60 L60 120 L80 140 L80 200" stroke="white" stroke-width="0.7" opacity="0.2"/>
      <path d="M40 0 L40 30 L60 50 L120 50 L140 70 L200 70" stroke="white" stroke-width="0.7" opacity="0.18"/>
      <path d="M0 80 L30 80 L50 100 L50 150" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M80 0 L80 25 L100 45 L150 45" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M60 60 L90 60 L110 80" stroke="white" stroke-width="0.4" opacity="0.1"/>
      <path d="M60 120 L40 120 L40 160" stroke="white" stroke-width="0.4" opacity="0.08"/>
      <circle cx="40" cy="40" r="2" fill="white" opacity="0.4"/>
      <circle cx="60" cy="60" r="2.5" fill="white" opacity="0.35"/>
      <circle cx="60" cy="120" r="2" fill="white" opacity="0.3"/>
      <circle cx="80" cy="140" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="80" cy="200" r="2" fill="white" opacity="0.2"/>
      <circle cx="120" cy="50" r="2" fill="white" opacity="0.3"/>
      <circle cx="140" cy="70" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="200" cy="70" r="2" fill="white" opacity="0.15"/>
      <circle cx="50" cy="100" r="1.5" fill="white" opacity="0.2"/>
      <circle cx="110" cy="80" r="1" fill="white" opacity="0.15"/>
      <circle cx="150" cy="45" r="1.5" fill="white" opacity="0.12"/>
      <circle cx="25" cy="25" r="1" fill="white" opacity="0.25"/>
      <circle cx="100" cy="30" r="0.8" fill="white" opacity="0.15"/>
      <circle cx="30" cy="140" r="0.8" fill="white" opacity="0.12"/>
      <circle cx="170" cy="55" r="0.6" fill="white" opacity="0.1"/>
    </svg>
    
    <!-- TOP RIGHT - Long extending circuit -->
    <svg class="hud-circuit hud-tr" viewBox="0 0 300 300" fill="none">
      <path d="M300 40 L260 40 L240 60 L240 120 L220 140 L220 200" stroke="white" stroke-width="0.7" opacity="0.2"/>
      <path d="M260 0 L260 30 L240 50 L180 50 L160 70 L100 70" stroke="white" stroke-width="0.7" opacity="0.18"/>
      <path d="M300 80 L270 80 L250 100 L250 150" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M220 0 L220 25 L200 45 L150 45" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M240 60 L210 60 L190 80" stroke="white" stroke-width="0.4" opacity="0.1"/>
      <circle cx="260" cy="40" r="2" fill="white" opacity="0.4"/>
      <circle cx="240" cy="60" r="2.5" fill="white" opacity="0.35"/>
      <circle cx="240" cy="120" r="2" fill="white" opacity="0.3"/>
      <circle cx="220" cy="140" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="220" cy="200" r="2" fill="white" opacity="0.2"/>
      <circle cx="180" cy="50" r="2" fill="white" opacity="0.3"/>
      <circle cx="160" cy="70" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="100" cy="70" r="2" fill="white" opacity="0.15"/>
      <circle cx="250" cy="100" r="1.5" fill="white" opacity="0.2"/>
      <circle cx="190" cy="80" r="1" fill="white" opacity="0.15"/>
      <circle cx="275" cy="25" r="1" fill="white" opacity="0.25"/>
      <circle cx="200" cy="30" r="0.8" fill="white" opacity="0.15"/>
      <circle cx="130" cy="55" r="0.6" fill="white" opacity="0.1"/>
    </svg>
    
    <!-- BOTTOM LEFT - Long extending circuit -->
    <svg class="hud-circuit hud-bl" viewBox="0 0 300 300" fill="none">
      <path d="M0 260 L40 260 L60 240 L60 180 L80 160 L80 100" stroke="white" stroke-width="0.7" opacity="0.2"/>
      <path d="M40 300 L40 270 L60 250 L120 250 L140 230 L200 230" stroke="white" stroke-width="0.7" opacity="0.18"/>
      <path d="M0 220 L30 220 L50 200 L50 150" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M80 300 L80 275 L100 255 L150 255" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M60 240 L90 240 L110 220" stroke="white" stroke-width="0.4" opacity="0.1"/>
      <circle cx="40" cy="260" r="2" fill="white" opacity="0.4"/>
      <circle cx="60" cy="240" r="2.5" fill="white" opacity="0.35"/>
      <circle cx="60" cy="180" r="2" fill="white" opacity="0.3"/>
      <circle cx="80" cy="160" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="80" cy="100" r="2" fill="white" opacity="0.2"/>
      <circle cx="120" cy="250" r="2" fill="white" opacity="0.3"/>
      <circle cx="140" cy="230" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="200" cy="230" r="2" fill="white" opacity="0.15"/>
      <circle cx="50" cy="200" r="1.5" fill="white" opacity="0.2"/>
      <circle cx="110" cy="220" r="1" fill="white" opacity="0.15"/>
      <circle cx="25" cy="275" r="1" fill="white" opacity="0.25"/>
      <circle cx="100" cy="270" r="0.8" fill="white" opacity="0.15"/>
      <circle cx="170" cy="245" r="0.6" fill="white" opacity="0.1"/>
    </svg>
    
    <!-- BOTTOM RIGHT - Long extending circuit -->
    <svg class="hud-circuit hud-br" viewBox="0 0 300 300" fill="none">
      <path d="M300 260 L260 260 L240 240 L240 180 L220 160 L220 100" stroke="white" stroke-width="0.7" opacity="0.2"/>
      <path d="M260 300 L260 270 L240 250 L180 250 L160 230 L100 230" stroke="white" stroke-width="0.7" opacity="0.18"/>
      <path d="M300 220 L270 220 L250 200 L250 150" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M220 300 L220 275 L200 255 L150 255" stroke="white" stroke-width="0.5" opacity="0.12"/>
      <path d="M240 240 L210 240 L190 220" stroke="white" stroke-width="0.4" opacity="0.1"/>
      <circle cx="260" cy="260" r="2" fill="white" opacity="0.4"/>
      <circle cx="240" cy="240" r="2.5" fill="white" opacity="0.35"/>
      <circle cx="240" cy="180" r="2" fill="white" opacity="0.3"/>
      <circle cx="220" cy="160" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="220" cy="100" r="2" fill="white" opacity="0.2"/>
      <circle cx="180" cy="250" r="2" fill="white" opacity="0.3"/>
      <circle cx="160" cy="230" r="1.5" fill="white" opacity="0.25"/>
      <circle cx="100" cy="230" r="2" fill="white" opacity="0.15"/>
      <circle cx="250" cy="200" r="1.5" fill="white" opacity="0.2"/>
      <circle cx="190" cy="220" r="1" fill="white" opacity="0.15"/>
      <circle cx="275" cy="275" r="1" fill="white" opacity="0.25"/>
      <circle cx="200" cy="270" r="0.8" fill="white" opacity="0.15"/>
      <circle cx="130" cy="245" r="0.6" fill="white" opacity="0.1"/>
    </svg>
    
    <!-- Center content -->
    <div class="loader-content">
      <div class="loader-bar">
        <div class="loader-fill"></div>
      </div>
      
      <div class="loader-brand">
        <svg class="loader-wave" viewBox="0 0 50 16" fill="none">
          <path d="M0 8 L12 8 L16 3 L20 13 L24 3 L28 13 L32 8 L50 8" stroke="white" stroke-width="0.8" opacity="0.3"/>
        </svg>
        <span class="loader-text">ITEREX</span>
        <svg class="loader-wave" viewBox="0 0 50 16" fill="none">
          <path d="M0 8 L18 8 L22 3 L26 13 L30 3 L34 13 L38 8 L50 8" stroke="white" stroke-width="0.8" opacity="0.3"/>
        </svg>
      </div>
    </div>
  </div>
  
  <!-- CURSOR -->
  <div class="cursor" id="cursor">_</div>
  <div class="cursor-trail" id="cursorTrail1"></div>
  <div class="cursor-trail" id="cursorTrail2"></div>
  
  <!-- 3D CANVAS -->
  <div id="canvas-container"></div>
  
  <!-- PROGRESS -->
  <div class="progress">
    <div class="progress-dot active" data-index="0"></div>
    <div class="progress-dot" data-index="1"></div>
    <div class="progress-dot" data-index="2"></div>
    <div class="progress-dot" data-index="3"></div>
    <div class="progress-dot" data-index="4"></div>
  </div>
  
  <!-- CORNER ELEMENTS -->
  <div class="corner-bl">ITEREX.DEV © 2025</div>
  <div class="corner-br">
    <div class="tech-readout">
      <div class="tech-row">
        <span class="tech-label">STATUS</span>
        <span class="tech-value">READY</span>
        <div class="status-dot"></div>
      </div>
      <div class="tech-line"></div>
      <div class="tech-row">
        <span class="tech-label">SYS</span>
        <span class="tech-value">V1.0.25</span>
      </div>
    </div>
  </div>
  
  <!-- NAV -->
  <nav>
    <div class="logo">
      <span>Iterex</span>
    </div>
    <div class="nav-links">
      <a href="#about">About</a>
      <a href="#extensions">Work</a>
      <a href="#templates">Process</a>
      <a href="#contact">Contact</a>
    </div>
  </nav>
  
  <!-- ═══════════════════════════════════════════════════════════════════
       PANELS — Each one will be PINNED during scroll
  ═══════════════════════════════════════════════════════════════════ -->
  
  <!-- HERO - Hidden via .js-loading class only -->
  <section class="panel" id="hero">
    <div class="panel-content">
      <div class="panel-tag">AI-Accelerated Development</div>
      <h1>Iterate.<br>Execute.<br><span>Ship.</span></h1>
      <p>Premium digital experiences crafted through relentless iteration. Your vision, realized in days—not months.</p>
      <div class="hero-ctas">
        <a href="#contact" class="cta-btn cta-primary">Let's Build</a>
        <a href="#extensions" class="cta-btn cta-ghost">View Work <span class="cta-arrow">→</span></a>
      </div>
    </div>
  </section>
  
  <!-- ABOUT -->
  <section class="panel right" id="about">
    <div class="founder-card">
      <div class="founder-image">
        <img src="assets/headshot.webp" alt="Tyler Nicklin">
      </div>
      <div class="founder-info">
        <div class="founder-name">Tyler Nicklin</div>
        <div class="founder-title">Founder / AI Creative Director</div>
        <div class="founder-quote">"Every pixel earns its place."</div>
      </div>
    </div>
    <div class="panel-content">
      <div class="panel-tag">[ 001 / About ]</div>
      <h2>Human vision.<br>AI execution.</h2>
      <p>We combine creative direction with AI-accelerated development to build digital experiences that feel impossible. Hundreds of iterations — until it's undeniably right.</p>
      <p class="about-secondary">Born from frustration with traditional workflows, ITEREX exists to remove the barriers between bold ideas and flawless execution. Our human team sets the creative north star; AI handles the heavy lifting. The result: faster launches, lower costs, and work that stands out in a sea of sameness.</p>
    </div>
  </section>
  
  <!-- WORK (was Extensions) -->
  <section class="panel" id="extensions">
    <div class="work-container">
      <div class="panel-content work-content">
        <div class="panel-tag">[ 002 / Work ]</div>
        <h2>Selected projects.</h2>
        <p>Custom web development, brand identity, and digital experiences — shipped fast, built to last.</p>
      </div>
      <div class="work-grid">
        <a href="https://mocapwork.com" class="work-item" target="_blank">
          <div class="work-logo">
            <img src="assets/mw.webp" alt="MocapWork">
          </div>
          <span class="work-btn">MocapWork</span>
        </a>
        <a href="https://thefactory.gg" class="work-item" target="_blank">
          <div class="work-logo">
            <img src="assets/fac.webp" alt="The Factory">
          </div>
          <span class="work-btn">The Factory</span>
        </a>
        <a href="https://deploytemplate.com" class="work-item" target="_blank">
          <div class="work-logo">
            <img src="assets/dt.webp" alt="DeployTemplate">
          </div>
          <span class="work-btn">DeployTemplate</span>
        </a>
        <a href="https://majesticlevel.com" class="work-item" target="_blank">
          <div class="work-logo">
            <img src="assets/maj.webp" alt="Majestic Level">
          </div>
          <span class="work-btn">Majestic Level</span>
        </a>
        <a href="https://ward.gg" class="work-item" target="_blank">
          <div class="work-logo">
            <img src="assets/ward.webp" alt="Ward Gaming">
          </div>
          <span class="work-btn">Ward Gaming</span>
        </a>
        <a href="https://siren.tv" class="work-item" target="_blank">
          <div class="work-logo">
            <img src="assets/siren.webp" alt="Siren">
          </div>
          <span class="work-btn">Siren</span>
          <span class="work-warning">18+ · Adult Platform</span>
        </a>
      </div>
    </div>
  </section>
  
  <!-- PROCESS -->
  <section class="panel right" id="templates">
    <!-- Glassmorphic card on left with title and description -->
    <div class="process-card process-card-left">
      <div class="panel-tag">[ 003 / Process ]</div>
      <h2>How we<br>build.</h2>
      <p>Discovery. Design. Develop. Deploy. We move fast through iterative cycles — refining until every detail is right. You stay in the loop, we handle the heavy lifting.</p>
    </div>
    
    <!-- GIF in center -->
    <div class="process-phone-area">
      <img src="assets/claude.gif" alt="" class="process-gif">
    </div>
    
    <!-- Glassmorphic card on right explaining the collaboration -->
    <div class="process-card process-card-right">
      <div class="panel-tag">[ ITEREX + CLAUDE ]</div>
      <h2>Your vision.<br>1000+ edits.</h2>
      <p>Every pixel refined. Every interaction perfected. Your project evolves through relentless iteration until it feels inevitable. AI-accelerated craftsmanship.</p>
    </div>
    
    <!-- Timeline at bottom -->
    <div class="process-steps">
      <div class="timeline-line-container">
        <div class="timeline-line"></div>
      </div>
      <div class="process-step step-discovery">
        <span class="step-number">01</span>
        <span class="step-title">Discovery</span>
        <span class="step-desc">Understanding your vision</span>
      </div>
      <div class="process-step step-design">
        <span class="step-number">02</span>
        <span class="step-title">Design</span>
        <span class="step-desc">Planning the approach</span>
      </div>
      <div class="process-step step-develop">
        <span class="step-number">03</span>
        <span class="step-title">Develop</span>
        <span class="step-desc">Building with AI speed</span>
      </div>
      <div class="process-step step-deploy">
        <span class="step-number">04</span>
        <span class="step-title">Deploy</span>
        <span class="step-desc">Ship it live</span>
      </div>
    </div>
  </section>
  
  <!-- CONTACT FORM -->
  <section class="panel center" id="contact">
    <div class="panel-content">
      <div class="contact-glass-bubble">
        <div class="panel-tag">[ 004 / Contact ]</div>
        <h2>Let's build<br>something.</h2>
        <p>Ready to ship your next project at impossible speed?</p>
        
        <div class="form-error" id="form-error"></div>
        
        <form class="contact-form" id="contact-form">
          <div class="form-row">
            <div class="form-group">
              <label for="contact-name">Name</label>
              <input type="text" id="contact-name" name="name" placeholder="Your name" required>
            </div>
            <div class="form-group">
              <label for="contact-email">Email</label>
              <input type="email" id="contact-email" name="email" placeholder="you@company.com" required>
            </div>
          </div>
          
          <div class="form-group">
            <label for="contact-project">Project Type</label>
            <select id="contact-project" name="project_type" required>
              <option value="" disabled selected>Select a project type</option>
              <option value="website">Website / Web App</option>
              <option value="extension">Browser Extension</option>
              <option value="template">Custom Template</option>
              <option value="consultation">Consultation</option>
              <option value="other">Other</option>
            </select>
          </div>
          
          <div class="form-group">
            <label for="contact-message">Message</label>
            <textarea id="contact-message" name="message" placeholder="Tell me about your project..." required></textarea>
          </div>
          
          <button type="submit" class="contact-submit" id="contact-submit">
            <span class="btn-text">Send Message</span>
          </button>
        </form>
        
        <div class="form-success" id="form-success" style="display: none;">
          <h3>🚀 Message Sent!</h3>
          <p>Thanks for reaching out. I'll get back to you within 24 hours.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer Glass Bubble -->
  <div class="footer-glass-bubble">
    <div class="footer-left">
      <span class="footer-logo">ITEREX</span>
      <span class="footer-copy">© 2025 All rights reserved</span>
    </div>
    <div class="footer-right">
      <div class="footer-links">
        <span>Extensions</span>
        <span>Templates</span>
        <span>Motion Capture</span>
      </div>
    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════════
       THREE.JS + SCROLL SYSTEM
  ═══════════════════════════════════════════════════════════════════ -->
  
  <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // ═══════════════════════════════════════════════════════════════════
    // ITEREX - AI-Accelerated Web Development
    // ═══════════════════════════════════════════════════════════════════
    console.log(
      '%c ITEREX %c iterate. execute. ship. ',
      'background: linear-gradient(135deg, #ff6432, #ff9632); color: #0a0a0f; font-weight: bold; padding: 8px 12px; border-radius: 4px 0 0 4px; font-family: "Syne", sans-serif;',
      'background: #0a0a0f; color: #888; padding: 8px 12px; border-radius: 0 4px 4px 0; font-family: "Space Mono", monospace; font-size: 10px;'
    );

    // ═══════════════════════════════════════════════════════════════════
    // MOBILE DETECTION
    // ═══════════════════════════════════════════════════════════════════
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (isMobile) {
      console.log('%c📱 Mobile Device Detected', 'color: #ff6432; font-weight: bold;');
    }

    // ═══════════════════════════════════════════════════════════════════
    // BLUR SHADERS FOR LARGE ACCENT ORBS
    // ═══════════════════════════════════════════════════════════════════
    
    const HorizontalBlurShader = {
      uniforms: {
        tDiffuse: { value: null },
        h: { value: 1.0 / 512.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float h;
        varying vec2 vUv;
        void main() {
          vec4 sum = vec4(0.0);
          sum += texture2D(tDiffuse, vec2(vUv.x - 4.0 * h, vUv.y)) * 0.051;
          sum += texture2D(tDiffuse, vec2(vUv.x - 3.0 * h, vUv.y)) * 0.0918;
          sum += texture2D(tDiffuse, vec2(vUv.x - 2.0 * h, vUv.y)) * 0.12245;
          sum += texture2D(tDiffuse, vec2(vUv.x - 1.0 * h, vUv.y)) * 0.1531;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y)) * 0.1633;
          sum += texture2D(tDiffuse, vec2(vUv.x + 1.0 * h, vUv.y)) * 0.1531;
          sum += texture2D(tDiffuse, vec2(vUv.x + 2.0 * h, vUv.y)) * 0.12245;
          sum += texture2D(tDiffuse, vec2(vUv.x + 3.0 * h, vUv.y)) * 0.0918;
          sum += texture2D(tDiffuse, vec2(vUv.x + 4.0 * h, vUv.y)) * 0.051;
          gl_FragColor = sum;
        }
      `
    };
    
    const VerticalBlurShader = {
      uniforms: {
        tDiffuse: { value: null },
        v: { value: 1.0 / 512.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float v;
        varying vec2 vUv;
        void main() {
          vec4 sum = vec4(0.0);
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 4.0 * v)) * 0.051;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 3.0 * v)) * 0.0918;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 2.0 * v)) * 0.12245;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 1.0 * v)) * 0.1531;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y)) * 0.1633;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 1.0 * v)) * 0.1531;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 2.0 * v)) * 0.12245;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 3.0 * v)) * 0.0918;
          sum += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 4.0 * v)) * 0.051;
          gl_FragColor = sum;
        }
      `
    };

    // ═══════════════════════════════════════════════════════════════════
    // GLOBAL STATE
    // ═══════════════════════════════════════════════════════════════════
    
    let scrollLocked = true;
    const preventScroll = (e) => { 
      if (scrollLocked) {
        e.preventDefault();
      }
    };
    window.addEventListener('wheel', preventScroll, { passive: false });
    window.addEventListener('touchmove', preventScroll, { passive: false });
    window.addEventListener('keydown', (e) => {
      if (scrollLocked && [32, 33, 34, 35, 36, 37, 38, 39, 40].includes(e.keyCode)) e.preventDefault();
    });
    
    // Disable middle mouse click auto-scroll (breaks animations)
    window.addEventListener('mousedown', (e) => {
      if (e.button === 1) e.preventDefault();
    });
    window.addEventListener('auxclick', (e) => {
      if (e.button === 1) e.preventDefault();
    });
    
    // Auto-focus window on mouse enter so scrolling works without clicking
    document.addEventListener('mouseenter', () => window.focus());
    document.addEventListener('mousemove', () => {
      if (!document.hasFocus()) window.focus();
    }, { once: false, passive: true });
    
    const STATE = {
      progress: 0,
      section: 0,
      mouse: { x: 0, y: 0 },
      loaded: 0,
      total: 8,
      isScrolling: false,
      isAnimating: false,
      scrollTimeout: null,  // For Lenis scroll detection
      // Scroll velocity for glow effect
      scrollY: 0,
      lastScrollY: 0,
      scrollVelocity: 0,
      glowSpeed: 1.0,        // Current glow speed multiplier
      glowSpeedTarget: 1.0,  // Target glow speed (lerps toward this)
      glowLinger: 0          // How long to keep boosted speed after scrolling stops
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // UNIFIED TIMING SYSTEM - One animation language for the whole site
    // ═══════════════════════════════════════════════════════════════════
    
    // ═══════════════════════════════════════════════════════════════════
    // CINEMA - Unified Animation System
    // Everything moves together, one tempo, one rhythm
    // ═══════════════════════════════════════════════════════════════════
    
    const CINEMA = {
      // Core duration - slow and intentional
      duration: 1.4,
      
      // Single easing language
      ease: 'power3.out',        // Soft luxurious deceleration
      easeOut: 'power2.inOut',   // Smooth exits
      
      // Stagger between elements
      stagger: 0.12,
      staggerFast: 0.08,         // For many items (work cards, neurons)
      
      // Y travel distance
      yDistance: 120,
      
      // 3D model timing
      modelDuration: 1.6,        // Models feel heavier, move slower
      modelDelay: 0.1,           // Models start just after text
      
      // Scroll duration - SNAPPIER like Junni
      scrollBase: 1.2,           // Base scroll duration
      scrollPerSection: 0.25,    // Less additional time per section
      
      // Contact zoom (sacred - don't change values)
      contactZoom: 2.5
    };
    
    // Legacy alias for any code still referencing TIMING
    const TIMING = {
      duration: CINEMA.duration,
      durationFast: CINEMA.duration * 0.6,
      durationSlow: CINEMA.duration * 1.3,
      easeEnter: CINEMA.ease,
      easeExit: CINEMA.easeOut,
      easeMove: CINEMA.ease,
      stagger: CINEMA.stagger,
      staggerFast: CINEMA.staggerFast,
      yEnter: CINEMA.yDistance,
      yExit: CINEMA.yDistance,
      modelExitDuration: CINEMA.modelDuration,
      contact: { zoomDuration: CINEMA.contactZoom }
    };
    
    const MODELS = {};
    
    // Base Y positions for floating animation
    const MODEL_BASE_Y = {};
    
    // ═══════════════════════════════════════════════════════════════════
    // THREE.JS SETUP
    // ═══════════════════════════════════════════════════════════════════
    
    const container = document.getElementById('canvas-container');
    
    
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: false,
      powerPreference: 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x030303);
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMappingExposure = 1;
    renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
    container.appendChild(renderer.domElement);
    renderer.setClearColor(0x030303);  // Dark background
    
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x030303, 1, 25);  // Start fog closer for extreme zoom
    
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 3.5);  // Start closer for hero zoom effect
    
    
    // ═══════════════════════════════════════════════════════════════════
    // LIGHTS
    // ═══════════════════════════════════════════════════════════════════
    
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(5, 5, 5);
    scene.add(keyLight);
    
    const blueLight = new THREE.PointLight(0x4466ff, 3, 15);
    blueLight.position.set(-6, 2, 4);
    scene.add(blueLight);
    
    const pinkLight = new THREE.PointLight(0xff4488, 3, 15);
    pinkLight.position.set(6, -2, 4);
    scene.add(pinkLight);
    
    const greenLight = new THREE.PointLight(0x44ff88, 1.5, 12);
    greenLight.position.set(0, -4, 6);
    scene.add(greenLight);
    
    
    // ═══════════════════════════════════════════════════════════════════
    // BACKGROUND LAYERS — Modern, Subtle Depth
    // ═══════════════════════════════════════════════════════════════════
    
    // --- BACKGROUND PLANE WITH VIGNETTE (matches loader aesthetic) ---
    const bgPlaneGeometry = new THREE.PlaneGeometry(300, 200);
    const bgPlaneMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uGlowColor: { value: new THREE.Vector3(0.0, 0.0, 0.0) },  // RGB glow color
        uGlowIntensity: { value: 0.0 },  // Glow strength
        uRainbowMode: { value: 0.0 }  // 0 = static color, 1 = rainbow
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform vec3 uGlowColor;
        uniform float uGlowIntensity;
        uniform float uRainbowMode;
        varying vec2 vUv;
        
        // Noise function for grain
        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        // HSL to RGB
        vec3 hsl2rgb(vec3 c) {
          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
          return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
        }
        
        void main() {
          vec2 center = vUv - 0.5;
          float dist = length(center);
          float angle = atan(center.y, center.x);
          
          // Base color - slightly off-black
          vec3 color = vec3(0.04, 0.04, 0.045);
          
          // Vignette - darken edges
          float vignette = 1.0 - smoothstep(0.2, 0.9, dist * 1.4);
          color *= vignette * 0.9 + 0.1;
          
          // Radial glow effect
          if (uGlowIntensity > 0.0) {
            // Calculate glow color - either static or rainbow
            vec3 glowCol = uGlowColor;
            if (uRainbowMode > 0.5) {
              // Rainbow: hue shifts with angle and time
              float hue = fract(angle / 6.283 + uTime * 0.1);
              glowCol = hsl2rgb(vec3(hue, 0.85, 0.55));
            }
            
            // Radial gradient glow from center
            float glowFalloff = 1.0 - smoothstep(0.0, 0.7, dist);
            glowFalloff = pow(glowFalloff, 1.5);  // Soften falloff
            color += glowCol * glowFalloff * uGlowIntensity * 0.15;
          }
          
          // Subtle animated grain
          float grain = random(vUv + uTime * 0.01) * 0.03;
          color += grain - 0.015;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      depthWrite: false
    });
    
    const bgPlane = new THREE.Mesh(bgPlaneGeometry, bgPlaneMaterial);
    bgPlane.position.z = -60;
    scene.add(bgPlane);
    
    // --- SPHERICAL GRID (Perfect squares with curved lines like Alche) ---
    // Mobile scale factor for grid - makes grid cells proportionally smaller
    const gridScale = isMobile ? 0.55 : 1.0;
    
    const perspGridMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uMouse: { value: new THREE.Vector2(0, 0) },
        uCurve: { value: 7.0 },  // Grid curve strength - animate to 0 for flat
        uOpacity: { value: 1.0 }, // Global opacity for hiding in certain sections
        uScale: { value: gridScale }  // Scale factor for mobile
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec2 vWorldXY;
        void main() {
          vUv = uv;
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vWorldXY = worldPos.xy;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform vec2 uResolution;
        uniform vec2 uMouse;
        uniform float uCurve;
        uniform float uOpacity;
        uniform float uScale;
        varying vec2 vUv;
        varying vec2 vWorldXY;
        
        // Hash function for random filled squares
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        void main() {
          // World position for grid (keeps squares square)
          // Offset by mouse for parallax effect - slower than objects for depth
          // Scale by uScale for mobile (smaller = denser grid relative to screen)
          vec2 worldPos = (vWorldXY + uMouse * 0.15) / uScale;
          
          // Fade at edges (used by all layers)
          float fade = 1.0 - smoothstep(0.35, 0.8, length(vUv - 0.5));
          
          // ═══════════════════════════════════════════════════════════════
          // SHARED CURVE DISTORTION - Apply to all grid layers
          // ═══════════════════════════════════════════════════════════════
          float curveStrength = uCurve;
          vec2 fromCenter = (vUv - 0.5) * 2.0;
          
          // Squeeze factor - at edges, squeeze toward center
          float ySquish = 1.0 - abs(fromCenter.y) * abs(fromCenter.y) * curveStrength * 0.4;
          float xSquish = 1.0 - abs(fromCenter.x) * abs(fromCenter.x) * curveStrength * 0.4;
          ySquish = max(ySquish, 0.1);
          xSquish = max(xSquish, 0.1);
          
          // ═══════════════════════════════════════════════════════════════
          // LARGE ACCENT SQUARES - Scattered filled cells that blink around
          // ═══════════════════════════════════════════════════════════════
          float largeCellSize = 3.0;  // Much bigger than grid
          vec2 largeCellPos = worldPos / largeCellSize;
          
          // Apply same curve distortion
          float largeVPos = largeCellPos.x * ySquish;
          float largeHPos = largeCellPos.y * xSquish;
          vec2 curvedLargeCell = vec2(largeVPos, largeHPos);
          
          vec2 largeCell = floor(curvedLargeCell);
          vec2 largeCellUV = fract(curvedLargeCell);
          
          // Time-based blinking - each cell gets its own blink cycle
          float blinkSpeed = 0.07;  // How fast squares change
          float cellTime = floor(uTime * blinkSpeed + hash(largeCell) * 10.0);
          float fillRandom = hash(largeCell + cellTime);
          
          // Fade in/out for smooth transitions
          float blinkPhase = fract(uTime * blinkSpeed + hash(largeCell) * 10.0);
          float blinkFade = smoothstep(0.0, 0.15, blinkPhase) * smoothstep(1.0, 0.85, blinkPhase);
          
          float isFilled = step(0.82, fillRandom);
          
          // Soft square (not hard edges)
          vec2 fromCellCenter = abs(largeCellUV - 0.5);
          float squareDist = max(fromCellCenter.x, fromCellCenter.y);
          float squareMask = 1.0 - smoothstep(0.3, 0.45, squareDist);
          
          float largeSquares = isFilled * squareMask * blinkFade;
          
          // ═══════════════════════════════════════════════════════════════
          // EXTRA LARGE SQUARES - Even bigger, also blink but slower
          // ═══════════════════════════════════════════════════════════════
          float xlCellSize = 4.5;  // 1.5x bigger than large squares
          vec2 xlCellPos = worldPos / xlCellSize;
          
          // Apply curve distortion
          float xlVPos = xlCellPos.x * ySquish;
          float xlHPos = xlCellPos.y * xSquish;
          vec2 curvedXLCell = vec2(xlVPos, xlHPos);
          
          vec2 xlCell = floor(curvedXLCell);
          vec2 xlCellUV = fract(curvedXLCell);
          
          // Slower blink for XL squares
          float xlBlinkSpeed = 0.035;
          float xlCellTime = floor(uTime * xlBlinkSpeed + hash(xlCell + 50.0) * 10.0);
          float xlFillRandom = hash(xlCell + xlCellTime + 100.0);
          
          // Fade in/out
          float xlBlinkPhase = fract(uTime * xlBlinkSpeed + hash(xlCell + 50.0) * 10.0);
          float xlBlinkFade = smoothstep(0.0, 0.2, xlBlinkPhase) * smoothstep(1.0, 0.8, xlBlinkPhase);
          
          float xlIsFilled = step(0.85, xlFillRandom);
          
          // Soft square
          vec2 xlFromCellCenter = abs(xlCellUV - 0.5);
          float xlSquareDist = max(xlFromCellCenter.x, xlFromCellCenter.y);
          float xlSquareMask = 1.0 - smoothstep(0.3, 0.45, xlSquareDist);
          
          // Only show XL square if NO large square is present at this pixel
          float xlSquares = xlIsFilled * xlSquareMask * xlBlinkFade * (1.0 - largeSquares);
          
          // ═══════════════════════════════════════════════════════════════
          // DOT PATTERN - Tiny dots for texture depth (behind grid)
          // ═══════════════════════════════════════════════════════════════
          float dotSpacing = 0.15;  // Smaller = more dots
          vec2 dotCell = worldPos / dotSpacing;
          vec2 dotUV = fract(dotCell) - 0.5;
          float dotDist = length(dotUV);
          float dotSize = 0.4;  // Size of each dot
          float dots = 1.0 - smoothstep(dotSize - 0.02, dotSize, dotDist);
          
          // ═══════════════════════════════════════════════════════════════
          // GRID LINES - Main visible grid
          // ═══════════════════════════════════════════════════════════════
          float cellSize = 0.6;
          vec2 cellPos = worldPos / cellSize;
          
          // Apply squeeze - vertical lines squeeze based on Y, horizontal based on X
          float vLinePos = cellPos.x * ySquish;
          float hLinePos = cellPos.y * xSquish;
          
          // Draw lines
          float lineWidth = 0.034;
          float vLine = abs(fract(vLinePos) - 0.5);
          float hLine = abs(fract(hLinePos) - 0.5);
          
          float vertical = 1.0 - smoothstep(lineWidth, lineWidth + 0.01, vLine);
          float horizontal = 1.0 - smoothstep(lineWidth, lineWidth + 0.01, hLine);
          
          float grid = max(horizontal, vertical);
          
          // ═══════════════════════════════════════════════════════════════
          // COMBINE ALL LAYERS (back to front, additive stacking)
          // ═══════════════════════════════════════════════════════════════
          vec3 color = vec3(1.0);
          
          // Layer 0 (FARTHEST BACK): Extra large squares
          float xlSquareAlpha = xlSquares * fade * 0.02;
          
          // Layer 1: Large squares
          float largeSquareAlpha = largeSquares * fade * 0.06;
          
          // Layer 2: Dot texture
          float dotAlpha = dots * fade * 0.02;
          
          // Layer 3 (FRONT): Grid lines - most visible
          float gridAlpha = grid * fade * 0.03;
          
          // Additive blend - back layers show through, front layers on top
          float alpha = xlSquareAlpha + largeSquareAlpha + dotAlpha + gridAlpha;
          
          gl_FragColor = vec4(color, alpha * uOpacity);
        }
      `,
      transparent: true,
      depthWrite: false
    });
    
    const perspGrid = new THREE.Mesh(
      new THREE.PlaneGeometry(120, 120),
      perspGridMaterial
    );
    perspGrid.position.z = -20;
    scene.add(perspGrid);
    
    // --- GRADIENT ORB GLOWS (soft, modern) ---
    const orbGeometry = new THREE.PlaneGeometry(30, 30);
    
    const createGradientOrb = (color, position, scale) => {
      const orbMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uColor: { value: new THREE.Color(color) },
          uTime: { value: 0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 uColor;
          uniform float uTime;
          varying vec2 vUv;
          
          void main() {
            vec2 center = vUv - 0.5;
            float dist = length(center);
            
            // Soft radial gradient
            float alpha = smoothstep(0.5, 0.0, dist) * 0.15;
            
            // Subtle pulse
            alpha *= 0.8 + sin(uTime * 0.5) * 0.2;
            
            gl_FragColor = vec4(uColor, alpha);
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      const orb = new THREE.Mesh(orbGeometry, orbMaterial);
      orb.position.set(position.x, position.y, position.z);
      orb.scale.setScalar(scale);
      orb.userData.material = orbMaterial;
      return orb;
    };
    
    // BACKGROUND ELEMENTS REMOVED FOR CLEAN LOOK
    const orbs = [];
    // orbs.push(createGradientOrb(0x4466ff, { x: -8, y: 3, z: -15 }, 2));
    // orbs.push(createGradientOrb(0xff4488, { x: 10, y: -2, z: -20 }, 2.5));
    // ═══════════════════════════════════════════════════════════════════
    // HOLOGRAPHIC SHADER MATERIAL
    // ═══════════════════════════════════════════════════════════════════
    
    const holoUniforms = { uTime: { value: 0 }, uMouse: { value: new THREE.Vector2(0.5, 0.5) } };
    
    const holoMat = () => new THREE.ShaderMaterial({
      uniforms: holoUniforms,
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec2 vUv;
        uniform float uTime;
        uniform vec2 uMouse;
        void main() {
          vec3 viewDir = normalize(cameraPosition - vWorldPosition);
          float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), 1.5);
          float angle = dot(vNormal, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;
          float viewAngle = dot(viewDir, vec3(1.0, 0.0, 0.0)) * 0.5 + 0.5;
          float timeShift = uTime * 1.00;
          vec3 color1 = vec3(0.76, 0.44, 0.71);
          vec3 color2 = vec3(0.00, 0.78, 1.00);
          vec3 color3 = vec3(0.40, 0.30, 1.00);
          vec3 color4 = vec3(0.96, 1.00, 0.20);
          float t1 = sin(angle * 6.28 + timeShift + viewAngle * 3.0) * 0.5 + 0.5;
          float t2 = sin(angle * 6.28 + timeShift + 2.09 + viewAngle * 2.0) * 0.5 + 0.5;
          float t3 = cos(viewAngle * 6.28 + timeShift * 0.5) * 0.5 + 0.5;
          vec3 holoColor = mix(color1, color2, t1);
          holoColor = mix(holoColor, color3, t2 * 1.00);
          holoColor = mix(holoColor, color4, t3 * 0.00);
          vec3 finalColor = holoColor * (fresnel * 0.80 + 1.00);
          finalColor += vec3(1.00, 0.98, 0.20) * pow(fresnel, 6.0) * 2.00;
          float alpha = fresnel * 1.00 + 0.00;
          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // RAINBOW HOLOGRAPHIC MATERIAL - Vibrant spectrum effect for robot
    // ═══════════════════════════════════════════════════════════════════
    
    const rainbowHoloMat = () => new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec3 vViewPosition;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vViewPosition = -mvPosition.xyz;
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec3 vViewPosition;
        uniform float uTime;
        
        // HSL to RGB conversion
        vec3 hsl2rgb(vec3 c) {
          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
          return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
        }
        
        void main() {
          vec3 viewDir = normalize(vViewPosition);
          vec3 normal = normalize(vNormal);
          
          // Fresnel for edge glow
          float fresnel = pow(1.0 - abs(dot(viewDir, normal)), 2.5);
          
          // Rainbow based on normal direction + time
          float hue = dot(normal, vec3(0.5, 1.0, 0.3)) * 0.5 + 0.5;
          hue += uTime * 0.15; // Slow color shift
          hue += fresnel * 0.3; // Edge color variation
          hue = fract(hue); // Keep in 0-1 range
          
          // Vibrant saturated rainbow
          vec3 rainbow = hsl2rgb(vec3(hue, 0.9, 0.55));
          
          // Add sparkle based on view angle - reduced for less white glare
          float sparkle = pow(max(dot(reflect(-viewDir, normal), vec3(0.5, 1.0, 0.5)), 0.0), 32.0);
          
          // Combine rainbow with fresnel glow - reduced fresnel intensity
          vec3 finalColor = rainbow * (1.0 + fresnel * 0.8);
          finalColor += vec3(1.0) * sparkle * 0.2; // Reduced white sparkle highlights
          finalColor += rainbow * pow(fresnel, 4.0) * 1.2; // Reduced colored edge glow
          
          // Semi-transparent
          gl_FragColor = vec4(finalColor, 0.2);
        }
      `,
      transparent: true,
      side: THREE.FrontSide,  // FrontSide only to prevent self-flickering
      depthWrite: false
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // HERO LOGO - Center of screen, spinning + interactive
    // ═══════════════════════════════════════════════════════════════════
    
    let heroLogo = null;
    
    // Logo interaction state
    const logoInteraction = {
      isHovering: false,
      lastMouseX: 0,
      lastMouseY: 0,
      velocityY: 0,
      velocityX: 0
    };
    
    // Logo pull effect (like brain loader) - follows mouse with friction
    const logoMouse = { x: 0, y: 0 };
    const logoPullTarget = { x: 0, y: 0 };
    const logoPullCurrent = { x: 0, y: 0 };
    const logoPullFriction = 0.03;  // Lower = more friction/slower
    const logoPullStrength = 0.25;  // How much it tilts toward mouse
    
    // Robot interaction state (same as logo, for contact section)
    const robotInteraction = {
      isHovering: false,
      lastMouseX: 0,
      lastMouseY: 0,
      velocityY: 0,
      velocityX: 0
    };
    
    // Robot pull effect - follows mouse with friction
    const robotMouse = { x: 0, y: 0 };
    const robotPullTarget = { x: 0, y: 0 };
    const robotPullCurrent = { x: 0, y: 0 };
    const robotPullFriction = 0.03;
    const robotPullStrength = 0.25;
    
    // Raycaster for logo hover/click detection
    const logoRaycaster = new THREE.Raycaster();
    const logoMouseVec = new THREE.Vector2(); // Reusable vector for raycasting
    
    
    const gltfLoader = new GLTFLoader();
    
    // Set up Draco decoder for compressed models
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
    gltfLoader.setDRACOLoader(dracoLoader);
    
    
    // ═══════════════════════════════════════════════════════════════════
    // BIG ITEREX TEXT - Behind the logo
    // ═══════════════════════════════════════════════════════════════════
    
    const heroTextCanvas = document.createElement('canvas');
    heroTextCanvas.width = 1024;
    heroTextCanvas.height = 256;
    const heroTextCtx = heroTextCanvas.getContext('2d');
    heroTextCtx.fillStyle = 'rgba(0, 0, 0, 0)';
    heroTextCtx.fillRect(0, 0, heroTextCanvas.width, heroTextCanvas.height);
    heroTextCtx.filter = 'blur(3px)';
    heroTextCtx.font = '700 100px Syne, sans-serif';
    heroTextCtx.fillStyle = '#ffffff';
    heroTextCtx.textAlign = 'center';
    heroTextCtx.textBaseline = 'middle';
    heroTextCtx.fillText('ITEREX', heroTextCanvas.width / 2, heroTextCanvas.height / 2);
    heroTextCtx.filter = 'none';
    
    const heroTextTexture = new THREE.CanvasTexture(heroTextCanvas);
    heroTextTexture.needsUpdate = true;
    
    const heroTextMaterial = new THREE.MeshBasicMaterial({
      map: heroTextTexture,
      transparent: true,
      depthWrite: false
    });
    
    const heroTextPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(20, 5),
      heroTextMaterial
    );
    heroTextPlane.position.set(0, 0, -8);
    heroTextPlane.renderOrder = 0;  // Render behind DNA/neurons
    scene.add(heroTextPlane);
    
    // Track scroll offset for parallax combination
    const heroScrollOffset = { y: 0, textY: 0 };
    
    // ═══════════════════════════════════════════════════════════════════
    // REFRACTION RENDER TARGET - Capture background for logo distortion
    // ═══════════════════════════════════════════════════════════════════
    
    const refractionRT = new THREE.WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight,
      { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter }
    );
    
    // Refraction shader for logo - warps background like glass
    const refractionUniforms = {
      uTime: holoUniforms.uTime,
      uBackground: { value: refractionRT.texture },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uRefractionStrength: { value: 0.10 },
      uChromaticAberration: { value: 0.03 }
    };
    
    const refractionMat = () => new THREE.ShaderMaterial({
      uniforms: refractionUniforms,
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec4 vScreenPos;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPos.xyz;
          vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          vScreenPos = clipPos;
          gl_Position = clipPos;
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec4 vScreenPos;
        varying vec2 vUv;
        uniform float uTime;
        uniform sampler2D uBackground;
        uniform vec2 uResolution;
        uniform float uRefractionStrength;
        uniform float uChromaticAberration;
        
        // Noise functions
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }
        
        void main() {
          // Screen UV from clip space
          vec2 screenUV = (vScreenPos.xy / vScreenPos.w) * 0.5 + 0.5;
          
          vec3 viewDir = normalize(cameraPosition - vWorldPosition);
          vec3 normal = normalize(vNormal);
          
          // Refraction offset based on normal
          vec2 refractOffset = normal.xy * uRefractionStrength;
          
          // Chromatic aberration - separate RGB channels
          float aberr = uChromaticAberration;
          vec2 uvR = screenUV + refractOffset * (1.0 + aberr);
          vec2 uvG = screenUV + refractOffset;
          vec2 uvB = screenUV + refractOffset * (1.0 - aberr);
          
          float r = texture2D(uBackground, uvR).r;
          float g = texture2D(uBackground, uvG).g;
          float b = texture2D(uBackground, uvB).b;
          vec3 refractedColor = vec3(r, g, b);
          
          // Fresnel for edge glow - power 2.0
          float fresnel = pow(1.0 - abs(dot(viewDir, normal)), 2.0);
          
          // Noise pattern on surface - scale 6.0
          vec2 noiseUV = vWorldPosition.xy * 6.0 + vWorldPosition.z * 2.0;
          float noisePattern = noise(noiseUV + uTime * 0.1);
          
          // FIRE COLORS 🔥
          float angle = dot(normal, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;
          float viewAngle = dot(viewDir, vec3(1.0, 0.0, 0.0)) * 0.5 + 0.5;
          float timeShift = uTime * 0.5;  // Color speed 0.5
          
          vec3 color1 = vec3(1.00, 0.30, 0.00);  // #ff4d00 orange
          vec3 color2 = vec3(1.00, 0.60, 0.00);  // #ff9900 yellow-orange
          vec3 color3 = vec3(1.00, 0.10, 0.10);  // #ff1a1a red
          
          float t1 = sin(angle * 6.28 + timeShift + viewAngle * 3.0) * 0.5 + 0.5;
          float t2 = sin(angle * 6.28 + timeShift + 2.09 + viewAngle * 2.0) * 0.5 + 0.5;
          
          vec3 holoColor = mix(color1, color2, t1);
          holoColor = mix(holoColor, color3, t2);
          
          // Apply noise - intensity 0.6
          holoColor *= 0.70 + noisePattern * 0.60;
          
          // Yellow-gold edge glow
          vec3 edgeGlow = vec3(1.00, 0.90, 0.30) * pow(fresnel, 3.0) * 0.9;
          
          // Blend refraction with holo effect - holoMix 1.2
          vec3 finalColor = refractedColor * 0.50 + holoColor * fresnel * 1.20;
          finalColor += edgeGlow;
          
          // Alpha - high base 0.9
          float alpha = 0.90 + fresnel * 0.10;
          
          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // ICE MATERIAL ❄️ - For About & Process sections
    // ═══════════════════════════════════════════════════════════════════
    const iceRefractionMat = () => new THREE.ShaderMaterial({
      uniforms: refractionUniforms,
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec4 vScreenPos;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPos.xyz;
          vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          vScreenPos = clipPos;
          gl_Position = clipPos;
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying vec4 vScreenPos;
        varying vec2 vUv;
        uniform float uTime;
        uniform sampler2D uBackground;
        uniform vec2 uResolution;
        uniform float uRefractionStrength;
        uniform float uChromaticAberration;
        
        // Noise functions
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }
        
        void main() {
          // Screen UV from clip space
          vec2 screenUV = (vScreenPos.xy / vScreenPos.w) * 0.5 + 0.5;
          
          vec3 viewDir = normalize(cameraPosition - vWorldPosition);
          vec3 normal = normalize(vNormal);
          
          // Refraction offset - 0.20
          vec2 refractOffset = normal.xy * 0.20;
          
          // Chromatic aberration - 0.01
          float aberr = 0.01;
          vec2 uvR = screenUV + refractOffset * (1.0 + aberr);
          vec2 uvG = screenUV + refractOffset;
          vec2 uvB = screenUV + refractOffset * (1.0 - aberr);
          
          float r = texture2D(uBackground, uvR).r;
          float g = texture2D(uBackground, uvG).g;
          float b = texture2D(uBackground, uvB).b;
          vec3 refractedColor = vec3(r, g, b);
          
          // Fresnel - power 2.0
          float fresnel = pow(1.0 - abs(dot(viewDir, normal)), 2.0);
          
          // Noise pattern - scale 12.0
          vec2 noiseUV = vWorldPosition.xy * 12.0 + vWorldPosition.z * 2.0;
          float noisePattern = noise(noiseUV + uTime * 0.1);
          
          // ❄️ ICE COLORS - cyan, teal-green, deep blue
          float angle = dot(normal, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;
          float viewAngle = dot(viewDir, vec3(1.0, 0.0, 0.0)) * 0.5 + 0.5;
          float timeShift = uTime * 0.5;  // Color speed 0.5
          
          vec3 color1 = vec3(0.29, 0.97, 1.00);  // #4af7ff cyan
          vec3 color2 = vec3(0.42, 0.93, 0.71);  // #6aeeb6 teal-green
          vec3 color3 = vec3(0.00, 0.17, 0.98);  // #002cfb deep blue
          
          float t1 = sin(angle * 6.28 + timeShift + viewAngle * 3.0) * 0.5 + 0.5;
          float t2 = sin(angle * 6.28 + timeShift + 2.09 + viewAngle * 2.0) * 0.5 + 0.5;
          
          vec3 holoColor = mix(color1, color2, t1);
          holoColor = mix(holoColor, color3, t2);
          
          // Apply noise - intensity 0.2
          holoColor *= 0.90 + noisePattern * 0.20;
          
          // Cyan edge glow
          vec3 edgeGlow = vec3(0.00, 0.88, 0.95) * pow(fresnel, 4.0) * 1.5;
          
          // Blend - refractionMix 0.8, holoMix 0.5
          vec3 finalColor = refractedColor * 0.80 + holoColor * fresnel * 0.50;
          finalColor += edgeGlow;
          
          // Alpha - 0.70 base + 0.30 fresnel
          float alpha = 0.70 + fresnel * 0.30;
          
          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // MODEL LOADING TRACKER - Pre-render all models to GPU after load
    // ═══════════════════════════════════════════════════════════════════
    const modelLoadTracker = {
      logo: false,
      balls: false,
      neurons: false,
      dna: false,
      brain: false,
      allLoaded: false,
      check: function() {
        if (this.logo && this.balls && this.neurons && this.dna && this.brain && !this.allLoaded) {
          this.allLoaded = true;
          this.preRenderAll();
        }
      },
      preRenderAll: function() {
        
        // Temporarily show all hidden models
        const wasVisible = {
          dna: dnaHelix ? dnaHelix.visible : false
        };
        
        if (dnaHelix) dnaHelix.visible = true;
        floatingNeurons.forEach(n => n.visible = true);
        
        // Force GPU upload by rendering
        renderer.render(scene, camera);
        
        // Restore visibility
        if (dnaHelix) dnaHelix.visible = wasVisible.dna;
        floatingNeurons.forEach(n => n.visible = false);
        
      }
    };
    
    gltfLoader.load('assets/logo.glb',
      (gltf) => {
        heroLogo = gltf.scene;
        heroLogo.traverse((child) => {
          if (child.isMesh) {
            child.material = refractionMat();
          }
        });
        // Mobile: smaller logo, CENTERED
        // Desktop: larger centered logo
        const logoScale = isMobile ? 1.6 : 3;
        const logoX = 0;  // Centered on both
        const logoY = isMobile ? 0.5 : 0;  // Slight up on mobile to not overlap text
        heroLogo.scale.setScalar(logoScale);
        heroLogo.position.set(logoX, logoY, -5);
        heroLogo.renderOrder = 0;  // Render behind DNA/neurons
        heroLogo.traverse((child) => {
          if (child.isMesh) child.renderOrder = 0;
        });
        scene.add(heroLogo);
        MODELS.logo = heroLogo;  // Add to MODELS for section transitions
        
        // ═══════════════════════════════════════════════════════════════
        // AMBIENT GLOW - Animated color wave radiating from center
        // ═══════════════════════════════════════════════════════════════
        const glowMaterial = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uThemeBlend: { value: 0 }  // 0 = fire, 1 = ice
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float uTime;
            uniform float uThemeBlend;
            varying vec2 vUv;
            
            void main() {
              // Distance from center
              vec2 center = vUv - 0.5;
              float dist = length(center);
              
              // 🔥 FIRE colors - orange, yellow-orange, red, deep red
              vec3 fireA = vec3(1.00, 0.40, 0.05);  // bright orange
              vec3 fireB = vec3(1.00, 0.65, 0.10);  // yellow-orange
              vec3 fireC = vec3(1.00, 0.20, 0.05);  // red-orange
              vec3 fireD = vec3(0.80, 0.15, 0.02);  // deep red
              
              // ❄️ ICE colors - cyan, teal, blue, deep blue
              vec3 iceA = vec3(0.29, 0.97, 1.00);   // bright cyan
              vec3 iceB = vec3(0.42, 0.93, 0.71);   // teal-green
              vec3 iceC = vec3(0.15, 0.60, 0.95);   // mid blue
              vec3 iceD = vec3(0.00, 0.17, 0.98);   // deep blue
              
              // Blend fire and ice palettes based on theme
              vec3 colorA = mix(fireA, iceA, uThemeBlend);
              vec3 colorB = mix(fireB, iceB, uThemeBlend);
              vec3 colorC = mix(fireC, iceC, uThemeBlend);
              vec3 colorD = mix(fireD, iceD, uThemeBlend);
              
              // Wave rotating through colors based on distance + time
              float wave = dist * 8.0 - uTime * 0.2;
              float t = fract(wave);
              
              // Cycle through blended colors
              vec3 color;
              float segment = mod(wave, 4.0);
              if (segment < 1.0) {
                color = mix(colorA, colorB, t);
              } else if (segment < 2.0) {
                color = mix(colorB, colorC, t);
              } else if (segment < 3.0) {
                color = mix(colorC, colorD, t);
              } else {
                color = mix(colorD, colorA, t);
              }
              
              // Fade out from center
              float alpha = smoothstep(0.5, 0.0, dist) * 0.08;
              
              gl_FragColor = vec4(color, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const logoGlow = new THREE.Mesh(
          new THREE.PlaneGeometry(17, 17),
          glowMaterial
        );
        logoGlow.position.set(0, 0, -6.5);  // Behind logo
        scene.add(logoGlow);
        
        // Store reference for animation
        heroLogo.userData.glow = logoGlow;
        heroLogo.userData.glowMaterial = glowMaterial;
        
        modelLoadTracker.logo = true;
        modelLoadTracker.check();
      },
      undefined,
      (error) => {
        console.warn('Logo not loaded:', error.message);
      }
    );
    
    // Logo interaction events - hover based rotation + pull effect mouse tracking
    document.addEventListener('mousemove', (e) => {
      // Always track mouse position for pull effect (even when not hovering)
      if (heroLogo && !isLoadingMode && STATE.section === 0) {
        logoMouse.x = (e.clientX / window.innerWidth) * 2 - 1;   // -1 to 1
        logoMouse.y = (e.clientY / window.innerHeight) * 2 - 1;  // -1 to 1
      }
      
      if (!heroLogo || isLoadingMode || STATE.isAnimating || STATE.isScrolling) return;
      
      // Only allow hover interaction in hero section
      if (STATE.section !== 0) return;
      
      // Check hover state - reuse vector to avoid garbage collection
      logoMouseVec.set(
        (e.clientX / window.innerWidth) * 2 - 1,
        -(e.clientY / window.innerHeight) * 2 + 1
      );
      logoRaycaster.setFromCamera(logoMouseVec, camera);
      const intersects = logoRaycaster.intersectObject(heroLogo, true);
      const wasHovering = logoInteraction.isHovering;
      logoInteraction.isHovering = intersects.length > 0;
      
      // If hovering over logo, calculate target velocity from mouse movement
      if (logoInteraction.isHovering) {
        const deltaX = e.clientX - logoInteraction.lastMouseX;
        const deltaY = e.clientY - logoInteraction.lastMouseY;
        
        // Target velocities - same sensitivity for both axes
        const targetVelY = deltaX * 0.002;
        const targetVelX = deltaY * 0.002;
        
        // Lerp toward target with friction (can't spin crazy fast)
        logoInteraction.velocityY += (targetVelY - logoInteraction.velocityY) * 0.3;
        logoInteraction.velocityX += (targetVelX - logoInteraction.velocityX) * 0.3;
        
        // Clamp max velocity
        const maxVel = 0.08;
        logoInteraction.velocityY = Math.max(-maxVel, Math.min(maxVel, logoInteraction.velocityY));
        logoInteraction.velocityX = Math.max(-maxVel, Math.min(maxVel, logoInteraction.velocityX));
      }
      
      logoInteraction.lastMouseX = e.clientX;
      logoInteraction.lastMouseY = e.clientY;
    });
    
    // Robot interaction events - same pull effect as logo, for contact section
    document.addEventListener('mousemove', (e) => {
      // Track mouse position for pull effect in contact section
      if (contactRobot && contactRobot.visible && !isLoadingMode && STATE.section === 4) {
        robotMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        robotMouse.y = (e.clientY / window.innerHeight) * 2 - 1;
      }
    });
    
    // DNA interaction events - hover based rotation (horizontal only)
    document.addEventListener('mousemove', (e) => {
      if (!dnaHelix || !dnaHelix.visible || isLoadingMode) return;
      
      // Reuse vector to avoid garbage collection
      dnaMouseVec.set(
        (e.clientX / window.innerWidth) * 2 - 1,
        -(e.clientY / window.innerHeight) * 2 + 1
      );
      dnaRaycaster.setFromCamera(dnaMouseVec, camera);
      const intersects = dnaRaycaster.intersectObject(dnaHelix, true);
      dnaInteraction.isHovering = intersects.length > 0;
      
      // If hovering, calculate velocity from horizontal mouse movement only
      if (dnaInteraction.isHovering) {
        const deltaX = e.clientX - dnaInteraction.lastMouseX;
        const targetVelY = deltaX * 0.003;
        dnaInteraction.velocityY += (targetVelY - dnaInteraction.velocityY) * 0.3;
        const maxVel = 0.1;
        dnaInteraction.velocityY = Math.max(-maxVel, Math.min(maxVel, dnaInteraction.velocityY));
      }
      
      dnaInteraction.lastMouseX = e.clientX;
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // FLOATING BALLS - Tiny holo orbs drifting around
    // ═══════════════════════════════════════════════════════════════════
    
    const floatingBalls = [];
    const ballCount = 17;  // 13 original + 4 larger accent balls
    
    // Mobile scale factor - shrink everything proportionally
    const mobileScale = isMobile ? 0.5 : 1;
    
    // Fixed positions for balls - first 7 smaller, next 6 bigger, last 4 large accent orbs
    // Positions and scales are multiplied by mobileScale for mobile devices
    const ballPositions = [
      // Smaller balls
      { x: -8 * mobileScale, y: -3 * mobileScale, z: -6, scale: 0.09 * mobileScale },
      { x: 10 * mobileScale, y: 4 * mobileScale, z: -8, scale: 0.075 * mobileScale },
      { x: -6 * mobileScale, y: 5 * mobileScale, z: -12, scale: 0.105 * mobileScale },
      { x: 8 * mobileScale, y: -4 * mobileScale, z: -10, scale: 0.06 * mobileScale },
      { x: -11 * mobileScale, y: 2 * mobileScale, z: -15, scale: 0.09 * mobileScale },
      { x: 5 * mobileScale, y: -2 * mobileScale, z: -5, scale: 0.075 * mobileScale },
      { x: -3 * mobileScale, y: 6 * mobileScale, z: -18, scale: 0.105 * mobileScale },
      // Bigger balls
      { x: 12 * mobileScale, y: -5 * mobileScale, z: -7, scale: 0.27 * mobileScale },
      { x: -10 * mobileScale, y: -4 * mobileScale, z: -9, scale: 0.33 * mobileScale },
      { x: 7 * mobileScale, y: 3 * mobileScale, z: -14, scale: 0.24 * mobileScale },
      { x: -5 * mobileScale, y: -6 * mobileScale, z: -11, scale: 0.30 * mobileScale },
      { x: 9 * mobileScale, y: 5 * mobileScale, z: -16, scale: 0.255 * mobileScale },
      { x: -12 * mobileScale, y: 4 * mobileScale, z: -13, scale: 0.285 * mobileScale },
      // Large accent orbs - more color, closer
      { x: -7 * mobileScale, y: -2 * mobileScale, z: -3, scale: 0.525 * mobileScale },   // Left side, close
      { x: 8 * mobileScale, y: 3 * mobileScale, z: -4, scale: 0.45 * mobileScale },     // Right side, close
      { x: -4 * mobileScale, y: 5 * mobileScale, z: -6, scale: 0.42 * mobileScale },    // Upper left
      { x: 6 * mobileScale, y: -4 * mobileScale, z: -5, scale: 0.48 * mobileScale }     // Lower right
    ];
    
    gltfLoader.load('assets/ball.glb',
      (gltf) => {
        for (let i = 0; i < ballCount; i++) {
          const ball = gltf.scene.clone();
          ball.traverse((child) => {
            if (child.isMesh) {
              child.material = refractionMat();
            }
          });
          
          const pos = ballPositions[i];
          ball.scale.setScalar(pos.scale);
          ball.position.set(pos.x, pos.y, pos.z);
          
          // Hide balls initially - will fade in with hero content
          ball.visible = false;
          
          // DOF layers: small=heavy blur (layer 2), medium=light blur (layer 1), large=minimal blur (layer 3)
          // On mobile: use layer 0 (no blur passes, render with main scene)
          // 0-6 = small (7), 7-12 = medium (6), 13-16 = large (4)
          let blurLayer = 0;  // Mobile: render with main scene
          if (!isMobile) {
            blurLayer = 3;  // Default: minimal blur (large orbs)
            if (i < 7) {
              blurLayer = 2;  // Small balls - heavy blur
            } else if (i < 13) {
              blurLayer = 1;  // Medium balls - light blur
            }
          }
          
          ball.layers.set(blurLayer);
          ball.traverse((child) => { child.layers.set(blurLayer); });
          
          // Store animation params - Z movement for depth
          ball.userData = {
            baseX: pos.x,
            baseY: pos.y,
            baseZ: pos.z,
            speedZ: 0.1 + (i * 0.002),
            ampZ: 1.5 + (i * 0.3),
            phase: i * 0.9,
            rotSpeed: 0.2 + (i * 0.05),
            blurLayer: blurLayer
          };
          
          scene.add(ball);
          floatingBalls.push(ball);
        }
        modelLoadTracker.balls = true;
        modelLoadTracker.check();
      },
      undefined,
      (error) => {
        console.warn('Ball not loaded:', error.message);
      }
    );
    
    // ═══════════════════════════════════════════════════════════════════
    // ABOUT SECTION - Floating neurons (scattered around screen)
    // ═══════════════════════════════════════════════════════════════════
    
    const floatingNeurons = [];
    // Neuron positions - scale down positions for mobile
    const neuronScale = isMobile ? 0.55 : 1;
    const neuronPositions = [
      // Small neurons
      { x: 9 * neuronScale, y: 8 * neuronScale, z: -10, scale: 0.6 * neuronScale },
      { x: 7 * neuronScale, y: -4 * neuronScale, z: -7, scale: 0.55 * neuronScale },    // Bottom right small
      // Medium neurons  
      { x: -11 * neuronScale, y: 2 * neuronScale, z: -6, scale: 1.1 * neuronScale },
      { x: -9 * neuronScale, y: -7 * neuronScale, z: -6, scale: 0.95 * neuronScale },   // Below founder, partially off-screen
      { x: 12 * neuronScale, y: 6 * neuronScale, z: -7, scale: 1.0 * neuronScale },     // Top right corner
      // Large neurons
      { x: -5 * neuronScale, y: 6.5 * neuronScale, z: -4, scale: 1.8 * neuronScale },   // Moved UP - halfway off screen
      { x: 11 * neuronScale, y: -5 * neuronScale, z: -3, scale: 1.6 * neuronScale },    // Bottom right, large
      // Near DNA - 2 small
      { x: -5 * neuronScale, y: -3 * neuronScale, z: -5, scale: 0.55 * neuronScale },   // Small, bottom left of DNA
      { x: 4 * neuronScale, y: 3.5 * neuronScale, z: -5, scale: 0.6 * neuronScale }    // Small, upper right of DNA
    ];
    
    gltfLoader.load('assets/neuron.glb',
      (gltf) => {
        for (let i = 0; i < neuronPositions.length; i++) {
          const neuron = gltf.scene.clone();
          neuron.traverse((child) => {
            if (child.isMesh) {
              child.material = iceRefractionMat();  // ❄️ ICE - About section
            }
          });
          
          const pos = neuronPositions[i];
          neuron.scale.setScalar(0.01);  // Start tiny
          neuron.position.set(pos.x, pos.y, -30);  // Start far back
          
          // Start hidden (deep in scene)
          neuron.visible = false;
          
          // DOF layers: small=heavy blur (layer 2), medium=light blur (layer 1), large=minimal blur (layer 3)
          // On mobile: use layer 0 (no blur passes, render with main scene)
          // 0,1 = small, 2,3,4 = medium, 5,6 = large, 7,8 = near-DNA small
          let blurLayer = 0;  // Mobile: render with main scene
          if (!isMobile) {
            blurLayer = 2;  // Default: heavy blur (small)
            if (i >= 2 && i <= 4) {
              blurLayer = 1;  // Medium neurons - light blur
            } else if (i === 5 || i === 6) {
              blurLayer = 3;  // Large neurons - minimal blur
            }
          }
          
          // Apply DOF blur layers (same system as floating balls)
          neuron.layers.set(blurLayer);
          neuron.traverse((child) => { child.layers.set(blurLayer); });
          
          // Store animation params
          neuron.userData = {
            baseX: pos.x,
            baseY: pos.y,
            baseZ: pos.z,
            baseScale: pos.scale,
            speedZ: 0.08 + (i * 0.015),
            ampZ: 1.2 + (i * 0.2),
            phase: i * 1.2,
            rotSpeed: 0.15 + (i * 0.03),
            blurLayer: blurLayer  // Store for DOF rendering
          };
          
          scene.add(neuron);
          floatingNeurons.push(neuron);
        }
        modelLoadTracker.neurons = true;
        modelLoadTracker.check();
      },
      undefined,
      (error) => {
        console.warn('Neuron not loaded:', error.message);
      }
    );
    
    // ═══════════════════════════════════════════════════════════════════
    // SKYLINE - Centerpiece for Work section
    // ═══════════════════════════════════════════════════════════════════
    // DNA HELIX - Meshy-generated centerpiece for About section
    // ═══════════════════════════════════════════════════════════════════
    
    let dnaHelix = null;
    let codeBracket = null;
    let contactRobot = null;
    
    // ═══════════════════════════════════════════════════════════════════
    // PRE-CREATED DNA CURVES - Avoid first-run lag from curve creation
    // ═══════════════════════════════════════════════════════════════════
    
    // Reusable vector to avoid GC stutter during animations
    const dnaTempVec = new THREE.Vector3();
    
    const dnaCurves = {
      // Entry from right (About section enter)
      entry: new THREE.CatmullRomCurve3([
        new THREE.Vector3(8, -4, 2),
        new THREE.Vector3(5, -2, 4),
        new THREE.Vector3(2, -0.5, 2),
        new THREE.Vector3(0, -0.35, -4)
      ]),
      entryScales: [5.0, 5.5, 5.0, 4.5],
      entryStart: new THREE.Vector3(8, -4, 2),
      
      // Exit to top-left (About section leave to Work)
      exit: new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.35, -4),
        new THREE.Vector3(-4, 2, 2),
        new THREE.Vector3(-10, 6, 0),
        new THREE.Vector3(-18, 12, -10)
      ]),
      exitScales: [4.5, 5.0, 5.5, 4.5],
      
      // Exit back to right/down (About leave back to Hero)
      exitBack: new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.35, -4),
        new THREE.Vector3(2, -2, 2),
        new THREE.Vector3(5, -4, 5),
        new THREE.Vector3(10, -7, 2),
        new THREE.Vector3(15, -10, -8)
      ]),
      exitBackScales: [4.5, 5.0, 6.5, 5.5, 4.5],
      
      // Re-entry from top-left (Work scrolling back up)
      reentry: new THREE.CatmullRomCurve3([
        new THREE.Vector3(-8, 4, 2),
        new THREE.Vector3(-5, 2, 4),
        new THREE.Vector3(-2, 0.5, 2),
        new THREE.Vector3(0, -0.35, -4)
      ]),
      reentryScales: [5.0, 5.5, 5.0, 4.5],
      reentryStart: new THREE.Vector3(-8, 4, 2)
    };
    
    // Pre-warm the curves by calling getPoint once
    dnaCurves.entry.getPoint(0.5);
    dnaCurves.exit.getPoint(0.5);
    dnaCurves.exitBack.getPoint(0.5);
    dnaCurves.reentry.getPoint(0.5);
    
    // DNA interaction state - horizontal only
    const dnaInteraction = {
      isHovering: false,
      lastMouseX: 0,
      velocityY: 0,
      autoRotateSpeed: 0.005,
      currentAutoSpeed: 0.005
    };
    const dnaRaycaster = new THREE.Raycaster();
    const dnaMouseVec = new THREE.Vector2(); // Reusable vector for raycasting
    
    gltfLoader.load('assets/dna.glb',
      (gltf) => {
        dnaHelix = gltf.scene;
        dnaHelix.traverse((child) => {
          if (child.isMesh) {
            child.material = iceRefractionMat();  // ❄️ ICE - About section
          }
        });
        
        // DNA helix setup - scale down for mobile
        const dnaScale = isMobile ? 2.5 : 4.0;
        dnaHelix.scale.setScalar(dnaScale);
        dnaHelix.position.set(12, -10, -2);  // Start position for bezier entry
        dnaHelix.rotation.x = 0.3;
        dnaHelix.rotation.z = 0.175;  // 10 degree tilt
        dnaHelix.visible = false;
        dnaHelix.renderOrder = 10;  // Render on top of logo/text
        dnaHelix.traverse((child) => {
          child.renderOrder = 10;
        });
        
        scene.add(dnaHelix);
        modelLoadTracker.dna = true;
        modelLoadTracker.check();
      },
      undefined,
      (error) => {
        console.warn('DNA not loaded:', error.message);
      }
    );
    
    // ═══════════════════════════════════════════════════════════════════
    // WORK SECTION HEAT PARTICLES - Rising from project cards
    // ═══════════════════════════════════════════════════════════════════
    
    const HEAT_PARTICLE_COUNT = 40;  // Lightweight count
    const heatParticleGeometry = new THREE.BufferGeometry();
    const heatPositions = new Float32Array(HEAT_PARTICLE_COUNT * 3);
    const heatVelocities = new Float32Array(HEAT_PARTICLE_COUNT);
    const heatLifetimes = new Float32Array(HEAT_PARTICLE_COUNT);
    const heatSizes = new Float32Array(HEAT_PARTICLE_COUNT);
    const heatColors = new Float32Array(HEAT_PARTICLE_COUNT * 3);
    
    // Initialize particles in the card grid area - centered within 580px from screen edges
    // Cards are in a 3x2 grid - spread a bit for coverage
    const cardPositions = [
      { x: -3, y: 0.5 },    // Top left
      { x: 0, y: 0.5 },     // Top center
      { x: 3, y: 0.5 },     // Top right
      { x: -3, y: -2 },     // Bottom left
      { x: 0, y: -2 },      // Bottom center
      { x: 3, y: -2 }       // Bottom right
    ];
    
    for (let i = 0; i < HEAT_PARTICLE_COUNT; i++) {
      // Pick a random card to spawn from
      const card = cardPositions[Math.floor(Math.random() * cardPositions.length)];
      
      // Moderate spread around each card
      heatPositions[i * 3] = card.x + (Math.random() - 0.5) * 2;        // x - moderate spread
      heatPositions[i * 3 + 1] = card.y + (Math.random() - 0.5) * 1.5;  // y
      heatPositions[i * 3 + 2] = -4.5 + Math.random() * 0.5;            // z - close to cards
      
      heatVelocities[i] = 0.4 + Math.random() * 0.3;  // Rise speed
      heatLifetimes[i] = Math.random();                // Stagger start times
      heatSizes[i] = 18 + Math.random() * 25;           // Bigger particles
      
      // Heat colors: orange, red, yellow spectrum
      const colorChoice = Math.random();
      if (colorChoice < 0.4) {
        // Orange
        heatColors[i * 3] = 1.0;
        heatColors[i * 3 + 1] = 0.4 + Math.random() * 0.2;
        heatColors[i * 3 + 2] = 0.1;
      } else if (colorChoice < 0.7) {
        // Red-orange
        heatColors[i * 3] = 1.0;
        heatColors[i * 3 + 1] = 0.2 + Math.random() * 0.2;
        heatColors[i * 3 + 2] = 0.05;
      } else {
        // Yellow-orange
        heatColors[i * 3] = 1.0;
        heatColors[i * 3 + 1] = 0.6 + Math.random() * 0.3;
        heatColors[i * 3 + 2] = 0.2;
      }
    }
    
    heatParticleGeometry.setAttribute('position', new THREE.BufferAttribute(heatPositions, 3));
    heatParticleGeometry.setAttribute('aVelocity', new THREE.BufferAttribute(heatVelocities, 1));
    heatParticleGeometry.setAttribute('aLifetime', new THREE.BufferAttribute(heatLifetimes, 1));
    heatParticleGeometry.setAttribute('aSize', new THREE.BufferAttribute(heatSizes, 1));
    heatParticleGeometry.setAttribute('aColor', new THREE.BufferAttribute(heatColors, 3));
    
    const heatParticleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uOpacity: { value: 0 }  // Fade in/out with section
      },
      vertexShader: `
        attribute float aVelocity;
        attribute float aLifetime;
        attribute float aSize;
        attribute vec3 aColor;
        
        uniform float uTime;
        uniform float uOpacity;
        
        varying float vAlpha;
        varying vec3 vColor;
        
        void main() {
          vColor = aColor;
          
          // Animate position - rise upward with slight wobble
          vec3 pos = position;
          float life = fract(aLifetime + uTime * 0.12 * aVelocity);
          
          // Rise from cards - tall enough to exit screen
          pos.y += life * 10.0;
          
          // Subtle horizontal drift
          pos.x += sin(uTime * 2.0 + aLifetime * 10.0) * 0.12;
          pos.z += cos(uTime * 1.5 + aLifetime * 8.0) * 0.08;
          
          // Fade in at start, fade out toward top
          float fadeIn = smoothstep(0.0, 0.15, life);
          float fadeOut = 1.0 - smoothstep(0.5, 0.8, life);
          vAlpha = fadeIn * fadeOut * uOpacity;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = aSize * (1.0 / -mvPosition.z) * (0.7 + life * 0.3);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying float vAlpha;
        varying vec3 vColor;
        
        void main() {
          // Soft circular particle with glow
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          
          // Soft falloff
          float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
          alpha *= vAlpha;
          
          // Add glow (brighter center)
          vec3 color = vColor * (1.0 + (1.0 - dist * 2.0) * 0.5);
          
          gl_FragColor = vec4(color, alpha * 0.6);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    
    const heatParticles = new THREE.Points(heatParticleGeometry, heatParticleMaterial);
    heatParticles.visible = false;
    heatParticles.renderOrder = 50;
    scene.add(heatParticles);
    
    // ═══════════════════════════════════════════════════════════════════
    // PROCESS SECTION - CODE BRACKET MODEL
    // ═══════════════════════════════════════════════════════════════════
    
    gltfLoader.load('assets/codebracket.glb',
      (gltf) => {
        codeBracket = gltf.scene;
        
        // ❄️ ICE material for Process section
        codeBracket.traverse((child) => {
          if (child.isMesh) {
            child.material = iceRefractionMat();
          }
        });
        
        // Start hidden, positioned above the GIF area
        codeBracket.visible = false;
        codeBracket.scale.setScalar(4.0);
        codeBracket.position.set(0, 3.95, -5);
        codeBracket.rotation.set(0, 0, 0);
        
        scene.add(codeBracket);
      },
      undefined,
      (error) => {
        console.warn('Code Bracket not loaded:', error.message);
      }
    );
    
    // ═══════════════════════════════════════════════════════════════════
    // CONTACT SECTION - ROBOT MODEL
    // ═══════════════════════════════════════════════════════════════════
    
    gltfLoader.load('assets/robot.glb',
      (gltf) => {
        contactRobot = gltf.scene;
        
        // 🌈 RAINBOW holographic material for Contact section
        const robotMaterial = rainbowHoloMat();
        contactRobot.traverse((child) => {
          if (child.isMesh) {
            child.material = robotMaterial;
            child.renderOrder = 100;  // Render after background
          }
        });
        
        // Store material reference for time updates
        contactRobot.userData.rainbowMat = robotMaterial;
        
        // Start hidden, positioned below viewport
        // Mobile: Scale down significantly to not overwhelm the screen
        contactRobot.visible = false;
        contactRobot.scale.setScalar(isMobile ? 1.8 : 5.4);
        contactRobot.position.set(0, isMobile ? -5 : -20, isMobile ? 4 : -5);
        contactRobot.rotation.set(0, 0, 0);
        contactRobot.renderOrder = 100;
        
        scene.add(contactRobot);
      },
      undefined,
      (error) => {
        console.warn('Robot not loaded:', error.message);
      }
    );
    
    // ═══════════════════════════════════════════════════════════════════
    // PROCESS SECTION CLAUDE MODELS (scattered around phone/title)
    // ═══════════════════════════════════════════════════════════════════
    // LOADER SCENE - Brain gets rendered here, then warped by shader
    // ═══════════════════════════════════════════════════════════════════
    
    const loaderScene = new THREE.Scene();
    
    const loaderCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    loaderCamera.position.z = 3;
    
    let loaderBrain = null;
    let brainGlow = null;
    
    // Mouse tracking for brain rotation
    const brainMouse = { x: 0, y: 0 };
    const brainTarget = { x: 0, y: 0 };
    const brainCurrent = { x: 0, y: 0 };
    const brainMaxRotation = 0.4; // Max rotation in radians (~23 degrees)
    const brainFriction = 0.04; // Lower = more friction/slower
    
    // Track mouse for brain
    document.addEventListener('mousemove', (e) => {
      brainMouse.x = (e.clientX / window.innerWidth) * 2 - 1;  // -1 to 1
      brainMouse.y = (e.clientY / window.innerHeight) * 2 - 1; // -1 to 1
    });
    
    // Create glow texture
    const glowCanvas = document.createElement('canvas');
    glowCanvas.width = 256;
    glowCanvas.height = 256;
    const glowCtx = glowCanvas.getContext('2d');
    const glowGrad = glowCtx.createRadialGradient(128, 128, 0, 128, 128, 128);
    glowGrad.addColorStop(0, 'rgba(80, 180, 220, 0.25)');
    glowGrad.addColorStop(0.3, 'rgba(60, 140, 180, 0.12)');
    glowGrad.addColorStop(0.6, 'rgba(40, 100, 140, 0.04)');
    glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    glowCtx.fillStyle = glowGrad;
    glowCtx.fillRect(0, 0, 256, 256);
    const glowTexture = new THREE.CanvasTexture(glowCanvas);
    
    gltfLoader.load('assets/brain.glb', 
      // Success
      (gltf) => {
        loaderBrain = gltf.scene;
        
        // ❄️ ICE - Brain in loader
        loaderBrain.traverse((child) => {
          if (child.isMesh) {
            child.material = iceRefractionMat();
          }
        });
        
        // Position above center (where loading bar will be below)
        loaderBrain.scale.setScalar(0.35);
        loaderBrain.position.set(0, 0.3, 0);
        loaderBrain.rotation.y = Math.PI;  // Spin 180 degrees to face forward
        
        // Add glow plane behind brain
        const glowGeom = new THREE.PlaneGeometry(2.5, 2.5);
        const glowMat = new THREE.MeshBasicMaterial({
          map: glowTexture,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          opacity: 0.8
        });
        brainGlow = new THREE.Mesh(glowGeom, glowMat);
        brainGlow.position.set(0, 0.3, -0.3);
        loaderScene.add(brainGlow);
        
        loaderScene.add(loaderBrain);
        
        modelLoadTracker.brain = true;
        modelLoadTracker.check();
      },
      // Progress
      undefined,
      // Error - just continue without brain
      (error) => {
        console.warn('Brain not loaded:', error.message);
      }
    );
    
    // ═══════════════════════════════════════════════════════════════════
    // POST-PROCESSING
    // ═══════════════════════════════════════════════════════════════════
    
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.15, 0.4, 0.9);
    
    // ─────────────────────────────────────────────────────────────────────
    // WATER DROP WAVE — Two-texture approach
    // tDiffuse = hero scene (revealed inside wave)
    // tLoader = loader screen (warped outside wave, pushed by wave edge)
    // ─────────────────────────────────────────────────────────────────────
    const PortalWarpShader = {
      uniforms: {
        tDiffuse: { value: null },         // Hero scene (from RenderPass)
        tLoader: { value: null },          // Loader texture (static capture)
        tBlurHeavy: { value: null },       // Heavy blur - small/distant balls
        tBlurLight: { value: null },       // Light blur - medium balls
        tBlurMin: { value: null },         // Minimal blur - large/close balls
        uWavePos: { value: -0.4 },          // Wave position (starts negative, grows into view)
        uStrength: { value: 3.5 },         // Bulge intensity
        uChroma: { value: 0.1 },           // Chromatic aberration (lingers)
        uPinch: { value: 1.5 },            // Initial pinch/twist to center
        uAspect: { value: window.innerWidth / window.innerHeight }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tLoader;
        uniform sampler2D tBlurHeavy;
        uniform sampler2D tBlurLight;
        uniform sampler2D tBlurMin;
        uniform float uWavePos;
        uniform float uStrength;
        uniform float uChroma;
        uniform float uPinch;
        uniform float uAspect;
        varying vec2 vUv;
        
        void main() {
          vec2 center = vec2(0.5, 0.5);
          
          // Aspect-corrected coordinates
          vec2 uv = vUv - center;
          uv.x *= uAspect;
          
          float dist = length(uv);
          float angle = atan(uv.y, uv.x);
          
          // ═══════════════════════════════════════════════════════════════
          // PINCH EFFECT — Pulls content TO center at the very start
          // ═══════════════════════════════════════════════════════════════
          
          float pinchEffect = uPinch * smoothstep(0.8, 0.0, dist) * smoothstep(0.0, 0.5, uWavePos);
          
          // ═══════════════════════════════════════════════════════════════
          // TRAVELING WAVE — Bulge concentrated at the wave edge
          // ═══════════════════════════════════════════════════════════════
          
          float toWave = dist - uWavePos;
          
          float bulgeWidth = 0.35;
          float bulge = exp(-toWave * toWave / (2.0 * bulgeWidth * bulgeWidth));
          bulge *= uStrength;
          bulge *= smoothstep(0.4, -0.1, toWave);
          
          // ═══════════════════════════════════════════════════════════════
          // LOADER UV — Text should STRETCH OUTWARD riding the wave
          // Sample from center → text appears at wave edge, stretched out
          // ═══════════════════════════════════════════════════════════════
          
          // The magic: sample loader from (dist - wavePos) 
          // At wave edge (dist=wavePos), this samples from 0 (center where text is)
          // So text appears to ride the wave outward!
          float loaderPullback = uWavePos * 0.9; // How much to pull toward center
          float waveInfluence = smoothstep(uWavePos + 0.3, uWavePos - 0.1, dist);
          float loaderSampleDist = dist - loaderPullback * waveInfluence;
          
          // Add bulge distortion on top
          loaderSampleDist = loaderSampleDist + pinchEffect * 0.2 - bulge * 0.2;
          loaderSampleDist = max(loaderSampleDist, 0.001);
          
          vec2 loaderUV = vec2(cos(angle), sin(angle)) * loaderSampleDist;
          loaderUV.x /= uAspect;
          loaderUV += center;
          
          // Chromatic aberration on loader (heavy at wave edge)
          float aberrAtWave = exp(-toWave * toWave / (2.0 * 0.15 * 0.15));
          float aberr = aberrAtWave * 0.06 * uChroma;
          
          vec2 loaderUvR = vec2(cos(angle), sin(angle)) * (loaderSampleDist + aberr);
          loaderUvR.x /= uAspect;
          loaderUvR += center;
          
          vec2 loaderUvB = vec2(cos(angle), sin(angle)) * (loaderSampleDist - aberr);
          loaderUvB.x /= uAspect;
          loaderUvB += center;
          
          float loaderR = texture2D(tLoader, loaderUvR).r;
          float loaderG = texture2D(tLoader, loaderUV).g;
          float loaderB = texture2D(tLoader, loaderUvB).b;
          vec3 loaderColor = vec3(loaderR, loaderG, loaderB);
          
          // ═══════════════════════════════════════════════════════════════
          // HERO UV — Subtle distortion at edge, clean in center
          // Inside the wave, we see the hero being revealed
          // ═══════════════════════════════════════════════════════════════
          
          float heroDistort = bulge * 0.1;
          float heroSampleDist = dist - heroDistort;
          heroSampleDist = max(heroSampleDist, 0.001);
          
          vec2 heroUV = vec2(cos(angle), sin(angle)) * heroSampleDist;
          heroUV.x /= uAspect;
          heroUV += center;
          
          // Subtle chromatic aberration on hero (lingers after wave passes)
          float heroAberrBehind = smoothstep(0.0, -1.5, toWave) * 0.3;
          float heroAberr = (aberrAtWave * 0.5 + heroAberrBehind) * 0.03 * uChroma;
          
          vec2 heroUvR = vec2(cos(angle), sin(angle)) * (heroSampleDist + heroAberr);
          heroUvR.x /= uAspect;
          heroUvR += center;
          
          vec2 heroUvB = vec2(cos(angle), sin(angle)) * (heroSampleDist - heroAberr);
          heroUvB.x /= uAspect;
          heroUvB += center;
          
          float heroR = texture2D(tDiffuse, heroUvR).r;
          float heroG = texture2D(tDiffuse, heroUV).g;
          float heroB = texture2D(tDiffuse, heroUvB).b;
          vec3 heroColor = vec3(heroR, heroG, heroB);
          
          // ═══════════════════════════════════════════════════════════════
          // MIX — INSIDE wave = hero, OUTSIDE wave = loader (warped)
          // No edge glow - clean transition
          // ═══════════════════════════════════════════════════════════════
          
          float revealEdge = uWavePos;
          float edgeSoftness = 0.05 + uWavePos * 0.1;
          float reveal = smoothstep(revealEdge + edgeSoftness, revealEdge - edgeSoftness, dist);
          
          // OUTSIDE wave (reveal=0) → loader | INSIDE wave (reveal=1) → hero
          vec3 finalColor = mix(loaderColor, heroColor, reveal);
          
          // Composite blurred DOF layers (additive blend)
          vec4 blurHeavy = texture2D(tBlurHeavy, vUv);  // Small/distant balls
          vec4 blurLight = texture2D(tBlurLight, vUv);  // Medium balls
          vec4 blurMin = texture2D(tBlurMin, vUv);      // Large/close balls
          finalColor += blurHeavy.rgb * blurHeavy.a;
          finalColor += blurLight.rgb * blurLight.a;
          finalColor += blurMin.rgb * blurMin.a;
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `
    };
    
    const warpPass = new ShaderPass(PortalWarpShader);
    
    // ═══════════════════════════════════════════════════════════════════
    // LOADER TEXTURE — Full-screen capture matching DOM loader
    // This becomes tLoader in the shader, gets warped at wave edge
    // ═══════════════════════════════════════════════════════════════════
    
    // Create full-screen loader using canvas - reduced resolution for performance
    const loaderCanvas = document.createElement('canvas');
    const updateLoaderCanvasSize = () => {
      // Cap at 1.5x native to reduce texture upload cost during loading
      const scale = Math.min(window.devicePixelRatio, 1.5);
      loaderCanvas.width = window.innerWidth * scale;
      loaderCanvas.height = window.innerHeight * scale;
    };
    updateLoaderCanvasSize();
    const loaderCtx = loaderCanvas.getContext('2d');
    
    // Load logo image - NO LONGER USED, keeping for reference
    let loaderProgress = 0;
    
    // Pre-generate noise texture once (not every frame!)
    const noiseCanvas = document.createElement('canvas');
    noiseCanvas.width = 256;
    noiseCanvas.height = 256;
    const noiseCtx = noiseCanvas.getContext('2d');
    const noiseData = noiseCtx.createImageData(256, 256);
    for (let i = 0; i < noiseData.data.length; i += 4) {
      const v = Math.random() * 20;
      noiseData.data[i] = v;
      noiseData.data[i + 1] = v;
      noiseData.data[i + 2] = v;
      noiseData.data[i + 3] = 30; // Low alpha for subtle effect
    }
    noiseCtx.putImageData(noiseData, 0, 0);
    
    // Offscreen canvas for static background (drawn once)
    let bgCache = null;
    let bgCacheW = 0, bgCacheH = 0;
    
    function createBgCache(w, h) {
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      const cx = w / 2;
      const cy = h / 2;
      
      // ═══════════════════════════════════════════════════════════════
      // LAYER 1: Slightly off-black base (so vignette has room to work)
      // ═══════════════════════════════════════════════════════════════
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, w, h);
      
      // ═══════════════════════════════════════════════════════════════
      // LAYER 2: Smooth vignette (9 stops for gradual fade)
      // ═══════════════════════════════════════════════════════════════
      const maxDim = Math.sqrt(w * w + h * h) / 2;
      const vignette = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxDim);
      vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
      vignette.addColorStop(0.2, 'rgba(0, 0, 0, 0)');
      vignette.addColorStop(0.4, 'rgba(0, 0, 0, 0.05)');
      vignette.addColorStop(0.5, 'rgba(0, 0, 0, 0.1)');
      vignette.addColorStop(0.6, 'rgba(0, 0, 0, 0.2)');
      vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0.35)');
      vignette.addColorStop(0.8, 'rgba(0, 0, 0, 0.5)');
      vignette.addColorStop(0.9, 'rgba(0, 0, 0, 0.7)');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.85)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, w, h);
      
      // ═══════════════════════════════════════════════════════════════
      // LAYER 3: Fine grain texture (subtle film grain)
      // ═══════════════════════════════════════════════════════════════
      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 12; // Reduced from 25
        data[i] = Math.min(255, Math.max(0, data[i] + noise));
        data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
        data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
      }
      ctx.putImageData(imageData, 0, 0);
      
      // ═══════════════════════════════════════════════════════════════
      // LAYER 4: Corner glows (soft light leaks)
      // ═══════════════════════════════════════════════════════════════
      const glows = [
        { x: 0, y: 0, color: '60, 80, 120' },
        { x: w, y: 0, color: '80, 60, 100' },
        { x: 0, y: h, color: '50, 70, 90' },
        { x: w, y: h, color: '70, 50, 80' },
      ];
      const glowRadius = Math.max(w, h) * 0.35;
      
      glows.forEach(g => {
        const glow = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, glowRadius);
        glow.addColorStop(0, `rgba(${g.color}, 0.1)`);
        glow.addColorStop(0.3, `rgba(${g.color}, 0.05)`);
        glow.addColorStop(0.6, `rgba(${g.color}, 0.02)`);
        glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, w, h);
      });
      
      // ═══════════════════════════════════════════════════════════════
      // LAYER 5: Scanlines (subtle CRT feel)
      // ═══════════════════════════════════════════════════════════════
      ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
      for (let y = 0; y < h; y += 3) {
        ctx.fillRect(0, y, w, 1);
      }
      
      return canvas;
    }
    
    function drawLoaderGraphics(progress) {
      loaderProgress = progress;
      const ctx = loaderCtx;
      const w = loaderCanvas.width;
      const h = loaderCanvas.height;
      const scale = Math.min(window.devicePixelRatio, 1.5);
      const cx = w / 2;
      const cy = h / 2;
      
      // Create/update cache if needed
      if (!bgCache || bgCacheW !== w || bgCacheH !== h) {
        bgCache = createBgCache(w, h);
        bgCacheW = w;
        bgCacheH = h;
      }
      
      // Draw cached background
      ctx.drawImage(bgCache, 0, 0);
      
      // ═══════════════════════════════════════════════════════════════
      // ORGANIC ELEMENTS AROUND LOADER (human, imperfect, scattered)
      // ═══════════════════════════════════════════════════════════════
      
      const textY = cy + 60 * scale;
      
      // Scattered motes around the loader area (asymmetric, organic placement)
      const motes = [
        // Upper left cluster (loose)
        { x: cx - 180 * scale, y: cy - 120 * scale, size: 1.5, opacity: 0.15 },
        { x: cx - 195 * scale, y: cy - 105 * scale, size: 2.5, opacity: 0.08 },
        { x: cx - 160 * scale, y: cy - 140 * scale, size: 1, opacity: 0.12 },
        // Upper right (sparser)
        { x: cx + 170 * scale, y: cy - 110 * scale, size: 2, opacity: 0.1 },
        { x: cx + 200 * scale, y: cy - 85 * scale, size: 1.2, opacity: 0.06 },
        // Lower scattered
        { x: cx - 140 * scale, y: cy + 150 * scale, size: 1.8, opacity: 0.09 },
        { x: cx + 155 * scale, y: cy + 135 * scale, size: 2.2, opacity: 0.07 },
        { x: cx + 120 * scale, y: cy + 165 * scale, size: 1.3, opacity: 0.11 },
        // Mid sides (asymmetric)
        { x: cx - 220 * scale, y: cy + 20 * scale, size: 1.6, opacity: 0.08 },
        { x: cx + 235 * scale, y: cy - 30 * scale, size: 2, opacity: 0.05 },
        // Near text (subtle accents)
        { x: cx - 95 * scale, y: textY - 25 * scale, size: 1, opacity: 0.1 },
        { x: cx + 110 * scale, y: textY + 18 * scale, size: 1.2, opacity: 0.08 },
      ];
      
      motes.forEach(m => {
        ctx.fillStyle = `rgba(255, 255, 255, ${m.opacity})`;
        ctx.beginPath();
        ctx.arc(m.x, m.y, m.size * scale, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Loose imperfect arc fragments (centered around whole composition)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
      ctx.lineWidth = 1 * scale;
      ctx.lineCap = 'round';
      
      // Arc fragment 1 (left side, wrapping brain to bar area)
      ctx.beginPath();
      ctx.arc(cx, cy + 30 * scale, 145 * scale, Math.PI * 0.85, Math.PI * 1.15);
      ctx.stroke();
      
      // Arc fragment 2 (right side, slightly different radius)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.035)';
      ctx.beginPath();
      ctx.arc(cx, cy + 25 * scale, 150 * scale, Math.PI * 1.9, Math.PI * 0.15);
      ctx.stroke();
      
      // Arc fragment 3 (top, subtle)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.025)';
      ctx.beginPath();
      ctx.arc(cx - 5 * scale, cy + 20 * scale, 155 * scale, Math.PI * 1.35, Math.PI * 1.55);
      ctx.stroke();
      
      // Small tick marks (mirrored on both sides)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
      ctx.lineWidth = 1 * scale;
      
      // Left of text - two horizontal marks
      const leftMarkX = cx - 85 * scale;
      ctx.beginPath();
      ctx.moveTo(leftMarkX, textY - 3 * scale);
      ctx.lineTo(leftMarkX - 12 * scale, textY - 3 * scale);
      ctx.stroke();
      
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
      ctx.beginPath();
      ctx.moveTo(leftMarkX - 3 * scale, textY + 5 * scale);
      ctx.lineTo(leftMarkX - 18 * scale, textY + 5 * scale);
      ctx.stroke();
      
      // Right of text - mirrored two horizontal marks
      const rightMarkX = cx + 80 * scale;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
      ctx.beginPath();
      ctx.moveTo(rightMarkX, textY - 3 * scale);
      ctx.lineTo(rightMarkX + 12 * scale, textY - 3 * scale);
      ctx.stroke();
      
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
      ctx.beginPath();
      ctx.moveTo(rightMarkX + 3 * scale, textY + 5 * scale);
      ctx.lineTo(rightMarkX + 18 * scale, textY + 5 * scale);
      ctx.stroke();
      
      // Small ITEREX text
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.font = `700 ${16 * scale}px Syne, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.letterSpacing = `${10 * scale}px`;
      ctx.fillText('ITEREX', cx, textY);
      
      // Loading bar - techy segmented data blocks
      // Narrower on mobile to fit the percentage text
      const barWidth = isMobile ? 140 * scale : 200 * scale;
      const barHeight = 6 * scale;
      const barX = cx - barWidth/2;
      const barY = cy + 110 * scale;
      
      // Number of segments
      const numSegments = 20;
      const segmentWidth = (barWidth - (numSegments - 1) * 2 * scale) / numSegments;
      const filledSegments = Math.floor(progress * numSegments);
      const partialFill = (progress * numSegments) % 1;
      
      // Draw segments
      for (let i = 0; i < numSegments; i++) {
        const segX = barX + i * (segmentWidth + 2 * scale);
        
        if (i < filledSegments) {
          // Filled segment - varying brightness for data feel
          const brightness = 0.7 + (((i * 7) % 10) / 10) * 0.3;
          ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
          ctx.fillRect(segX, barY, segmentWidth, barHeight);
        } else if (i === filledSegments) {
          // Partial fill segment (current)
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.fillRect(segX, barY, segmentWidth * partialFill, barHeight);
          // Background of partial
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.fillRect(segX + segmentWidth * partialFill, barY, segmentWidth * (1 - partialFill), barHeight);
        } else {
          // Empty segment
          ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
          ctx.fillRect(segX, barY, segmentWidth, barHeight);
        }
      }
      
      // Percentage counter
      const percent = Math.floor(progress * 100);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.font = `400 ${10 * scale}px monospace`;
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${percent.toString().padStart(3, '0')}%`, barX - 8 * scale, barY + barHeight / 2);
      
      // Data indicator on right
      ctx.textAlign = 'left';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillText('SYS', barX + barWidth + 8 * scale, barY + barHeight / 2);
      
      // Small blinking node (simulated with progress-based flicker)
      const blink = Math.sin(progress * Math.PI * 20) > 0.3;
      if (blink && progress < 1) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(barX + barWidth + 35 * scale, barY + barHeight / 2, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Small accent below bar (asymmetric)
      ctx.fillStyle = 'rgba(255, 255, 255, 0.04)';
      ctx.beginPath();
      ctx.arc(barX + barWidth * 0.3, barY + 18 * scale, 1.5 * scale, 0, Math.PI * 2);
      ctx.fill();
    }
    
    drawLoaderGraphics(1); // Draw complete loader
    
    const loaderTexture = new THREE.CanvasTexture(loaderCanvas);
    loaderTexture.minFilter = THREE.LinearFilter;
    loaderTexture.magFilter = THREE.LinearFilter;
    loaderTexture.colorSpace = THREE.LinearSRGBColorSpace;
    loaderTexture.needsUpdate = true;
    
    // Background quad in loaderScene - sized to fill entire viewport
    // Calculate size based on camera FOV and distance to fill screen exactly
    const bgDistance = 7;  // Distance from camera (at z=3) to quad (at z=-7) = 10
    const bgHeight = 2 * Math.tan((50 * Math.PI / 180) / 2) * (3 + bgDistance) * 1.1;  // Add 10% margin
    const bgWidth = bgHeight * (window.innerWidth / window.innerHeight);
    
    // Canvas content quad (circuits, text, loading bar)
    const bgQuadGeom = new THREE.PlaneGeometry(bgWidth, bgHeight);
    const bgQuadMat = new THREE.MeshBasicMaterial({ map: loaderTexture });
    const bgQuad = new THREE.Mesh(bgQuadGeom, bgQuadMat);
    bgQuad.position.z = -bgDistance;
    loaderScene.add(bgQuad);
    
    // Render target for combined loader (brain + text/bar)
    // Use lower resolution during loading for performance
    const loaderRT = new THREE.WebGLRenderTarget(
      window.innerWidth * Math.min(window.devicePixelRatio, 1.5),
      window.innerHeight * Math.min(window.devicePixelRatio, 1.5)
    );
    
    // Function to render loader scene to texture
    // Track if loader rendering is still needed
    let loaderNeedsRedraw = true;
    let loaderRenderNeeded = true;
    
    function renderLoaderToTexture() {
      // Skip entirely if loader is no longer visible
      if (!loaderRenderNeeded) return;
      
      // Only redraw canvas if needed (during loading animation)
      if (loaderNeedsRedraw) {
        drawLoaderGraphics(loaderProgress);
        loaderTexture.needsUpdate = true;
      }
      
      // Render brain + background to render target
      renderer.setRenderTarget(loaderRT);
      renderer.render(loaderScene, loaderCamera);
      renderer.setRenderTarget(null);
      
      warpPass.uniforms.tLoader.value = loaderRT.texture;
    }
    
    // Initialize tLoader
    warpPass.uniforms.tLoader = { value: loaderRT.texture };
    
    
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(warpPass);
    composer.addPass(bloomPass);
    
    
    // ═══════════════════════════════════════════════════════════════════
    // DOF BLUR COMPOSERS - Fixed ping-pong to prevent feedback loop
    // Let EffectComposer manage its own render targets internally
    // ═══════════════════════════════════════════════════════════════════
    
    // Create dummy transparent texture (prevents shader errors)
    const dummyTexture = new THREE.DataTexture(
      new Uint8Array([0, 0, 0, 0]), 1, 1, THREE.RGBAFormat
    );
    dummyTexture.needsUpdate = true;
    
    // Set dummy textures immediately to prevent any shader errors
    warpPass.uniforms.tBlurHeavy.value = dummyTexture;
    warpPass.uniforms.tBlurLight.value = dummyTexture;
    warpPass.uniforms.tBlurMin.value = dummyTexture;
    
    // Only create blur composers on desktop
    let heavyBlurComposer;
    let lightBlurComposer;
    let minBlurComposer;
    
    if (!isMobile) {
      // Heavy blur for small/distant balls (layer 2)
      // Don't pass render target - let EffectComposer manage its own ping-pong
      heavyBlurComposer = new EffectComposer(renderer);
      heavyBlurComposer.setSize(window.innerWidth, window.innerHeight);
      const heavyBlurRenderPass = new RenderPass(scene, camera);
      heavyBlurComposer.addPass(heavyBlurRenderPass);
      
      // 2 passes for moderate blur
      const hBlurHeavy1 = new ShaderPass(HorizontalBlurShader);
      hBlurHeavy1.uniforms.h.value = 0.5 / window.innerWidth;
      heavyBlurComposer.addPass(hBlurHeavy1);
      
      const vBlurHeavy1 = new ShaderPass(VerticalBlurShader);
      vBlurHeavy1.uniforms.v.value = 0.5 / window.innerHeight;
      heavyBlurComposer.addPass(vBlurHeavy1);
      
      const hBlurHeavy2 = new ShaderPass(HorizontalBlurShader);
      hBlurHeavy2.uniforms.h.value = 0.5 / window.innerWidth;
      heavyBlurComposer.addPass(hBlurHeavy2);
      
      const vBlurHeavy2 = new ShaderPass(VerticalBlurShader);
      vBlurHeavy2.uniforms.v.value = 0.5 / window.innerHeight;
      vBlurHeavy2.renderToScreen = false;
      heavyBlurComposer.addPass(vBlurHeavy2);
      
      // Light blur for medium balls (layer 1)
      lightBlurComposer = new EffectComposer(renderer);
      lightBlurComposer.setSize(window.innerWidth, window.innerHeight);
      const lightBlurRenderPass = new RenderPass(scene, camera);
      lightBlurComposer.addPass(lightBlurRenderPass);
      
      // 1 pass for medium balls
      const hBlurLight = new ShaderPass(HorizontalBlurShader);
      hBlurLight.uniforms.h.value = 0.7 / window.innerWidth;
      lightBlurComposer.addPass(hBlurLight);
      
      const vBlurLight = new ShaderPass(VerticalBlurShader);
      vBlurLight.uniforms.v.value = 0.7 / window.innerHeight;
      vBlurLight.renderToScreen = false;
      lightBlurComposer.addPass(vBlurLight);
      
      // Minimal blur for large/close balls (layer 3)
      minBlurComposer = new EffectComposer(renderer);
      minBlurComposer.setSize(window.innerWidth, window.innerHeight);
      const minBlurRenderPass = new RenderPass(scene, camera);
      minBlurComposer.addPass(minBlurRenderPass);
      
      const hBlurMin = new ShaderPass(HorizontalBlurShader);
      hBlurMin.uniforms.h.value = 0.25 / window.innerWidth;
      minBlurComposer.addPass(hBlurMin);
      
      const vBlurMin = new ShaderPass(VerticalBlurShader);
      vBlurMin.uniforms.v.value = 0.25 / window.innerHeight;
      vBlurMin.renderToScreen = false;
      minBlurComposer.addPass(vBlurMin);
    }
    
    
    // SHADER WARMUP - render one frame with composer to pre-compile shaders
    // This prevents lag spike when warp first kicks in
    composer.render();
    
    
    // Loading mode flag - when true, render loaderScene directly
    let isLoadingMode = true;
    
    // ═══════════════════════════════════════════════════════════════════
    // LOADING & WARP INTRO
    // ═══════════════════════════════════════════════════════════════════
    
    const loaderEl = document.querySelector('.loader');
    
    // Warp animation function
    let warpTriggered = false;
    function triggerWarpIntro() {
      if (warpTriggered) {
        return;
      }
      warpTriggered = true;
      
      
      // ═══════════════════════════════════════════════════════════════════
      // COMPREHENSIVE PRE-WARM - Force first render of everything
      // This eliminates the "first scroll" lag by warming up:
      // - DNA helix + its exit animation path
      // - All neurons + their exit animation
      // - Work section DOM elements (force layout/paint)
      // ═══════════════════════════════════════════════════════════════════
      
      // 1. Pre-warm DNA at its About section position
      if (dnaHelix) {
        const origPos = dnaHelix.position.clone();
        const origScale = dnaHelix.scale.clone();
        const origVisible = dnaHelix.visible;
        
        // Position DNA where it will be in About section
        // Use mobile-aware scale for pre-warming
        const dnaWarmScale = isMobile ? 2.8 : 4.5;
        dnaHelix.position.set(0, -0.35, -4);
        dnaHelix.scale.setScalar(dnaWarmScale);
        dnaHelix.visible = true;
        
        // Force render
        renderer.render(scene, camera);
        
        // Also pre-warm the exit path by sampling it
        for (let t = 0; t <= 1; t += 0.25) {
          dnaCurves.exitBack.getPoint(t, dnaTempVec);
        }
        
        // Restore
        dnaHelix.position.copy(origPos);
        dnaHelix.scale.copy(origScale);
        dnaHelix.visible = origVisible;
      }
      
      // 2. Pre-warm neurons at their About section positions
      if (floatingNeurons.length > 0) {
        const origStates = floatingNeurons.map(n => ({
          pos: n.position.clone(),
          scale: n.scale.clone(),
          visible: n.visible
        }));
        
        // Position neurons where they'll be in About
        floatingNeurons.forEach((neuron, i) => {
          neuron.position.set(
            neuron.userData.baseX || -3 + i * 0.5,
            neuron.userData.baseY || 0,
            neuron.userData.baseZ || 0
          );
          neuron.scale.setScalar(neuron.userData.baseScale || 0.4);
          neuron.visible = true;
        });
        
        // Force render
        renderer.render(scene, camera);
        
        // Restore
        floatingNeurons.forEach((neuron, i) => {
          neuron.position.copy(origStates[i].pos);
          neuron.scale.copy(origStates[i].scale);
          neuron.visible = origStates[i].visible;
        });
      }
      
      // 3. Pre-warm Work section DOM - force layout/paint
      const workItems = document.querySelectorAll('.work-item');
      const workGrid = document.querySelector('.work-grid');
      if (workGrid && workItems.length) {
        // Force layout calculation
        workGrid.offsetHeight;
        workItems.forEach(item => item.offsetHeight);
      }
      
      // 4. One more composer render to warm everything together
      composer.render();
      
      // ═══════════════════════════════════════════════════════════════════
      
      // Stop redrawing canvas - loading is done
      loaderNeedsRedraw = false;
      
      // Switch from loading mode to warp mode
      isLoadingMode = false;
      // Capture the loader screen to texture BEFORE hiding DOM loader
      renderLoaderToTexture();
      
      // STOP rendering loader NOW - we have our snapshot
      loaderRenderNeeded = false;
      
      // Now hide DOM loader - shader will show captured loader texture
      loaderEl.classList.add('hidden');
      
      // Hero hiding is now handled ONLY by .js-loading class
      // No gsap.set calls needed here - keeps things simple
      
      const tl = gsap.timeline({
        onComplete: () => {
        }
      });
      
      // Unlock scroll early - as soon as hero content starts appearing (0.5s)
      tl.call(() => {
        scrollLocked = false;
        document.documentElement.style.overflow = '';
        document.body.style.overflow = '';
        window.scrollTo(0, 0);
        ScrollTrigger.refresh();
        initScrollAnimations();
      }, null, 0.5);
      
      // ═══════════════════════════════════════════════════════════════
      // WATER DROP WAVE — Slow expansion, long settle, lingering chroma
      // Like a rock hitting water - rebound bulge travels outward
      // ═══════════════════════════════════════════════════════════════
      
      // PINCH — Quick "impact" at the very start (suck to center then release)
      tl.to(warpPass.uniforms.uPinch, {
        value: 0,
        duration: 0.8,
        ease: 'power2.out'
      }, 0);
      
      // Wave expands outward — SLOW, with long ease-out tail
      tl.to(warpPass.uniforms.uWavePos, {
        value: 2.5,
        duration: 4.5,
        ease: 'power2.out'  // Fast start, loooong slow finish
      }, 0);
      
      // Bulge strength fades — even SLOWER so distortion lingers
      tl.to(warpPass.uniforms.uStrength, {
        value: 0,
        duration: 5.5,
        ease: 'power1.out'  // Very gradual fade
      }, 0);
      
      // Chromatic aberration lingers the LONGEST — that blue/red fringe
      tl.to(warpPass.uniforms.uChroma, {
        value: 0,
        duration: 6.5,
        ease: 'power1.out'
      }, 0.5);  // Starts fading a bit later
      
      // Content reveals — appear during warp, not after
      
      // Nav and progress dots blur-in cinematically
      tl.to('.logo', { opacity: 1, filter: 'blur(0px)', duration: 1.0, ease: 'power2.out' }, 1.5);
      tl.to('.nav-links', { opacity: 1, filter: 'blur(0px)', duration: 1.0, ease: 'power2.out' }, 1.5);
      tl.to('.progress', { opacity: 1, filter: 'blur(0px)', duration: 1.0, ease: 'power2.out' }, 1.7);
      tl.to('.corner-bl', { opacity: 1, filter: 'blur(0px)', duration: 1.0, ease: 'power2.out' }, 1.9);
      tl.to('.corner-br', { opacity: 1, filter: 'blur(0px)', duration: 1.0, ease: 'power2.out' }, 2.0);
      
      // ═══════════════════════════════════════════════════════════════
      // HERO TEXT - Blur-in reveal timed with wave reaching left side
      // Wave reaches left edge around 0.5-0.6s, so reveal then
      // ═══════════════════════════════════════════════════════════════
      
      // Remove js-loading early so we can animate
      tl.call(() => {
        document.body.classList.remove('js-loading');
        // Set initial state for blur-in (must include visibility since base CSS hides them)
        gsap.set('#hero .panel-tag, #hero h1, #hero p, #hero .hero-ctas', {
          opacity: 0,
          visibility: 'visible',
          y: 0,
          filter: 'blur(10px)'
        });
      }, null, 0.4);
      
      // Blur-in reveal - starts right after set (0.5s) so no gap
      tl.to('#hero .panel-tag', { opacity: 1, visibility: 'visible', filter: 'blur(0px)', duration: 0.8, ease: 'power2.out' }, 0.5);
      tl.to('#hero h1', { opacity: 1, visibility: 'visible', filter: 'blur(0px)', duration: 0.8, ease: 'power2.out' }, 0.55);
      tl.to('#hero p', { opacity: 1, visibility: 'visible', filter: 'blur(0px)', duration: 0.8, ease: 'power2.out' }, 0.6);
      tl.to('#hero .hero-ctas', { opacity: 1, visibility: 'visible', filter: 'blur(0px)', duration: 0.8, ease: 'power2.out' }, 0.65);
      
      // Floating balls fade in with hero content
      tl.call(() => {
        floatingBalls.forEach((ball, i) => {
          ball.visible = true;
          // Stagger the appearance slightly
          gsap.from(ball.scale, { 
            x: 0, y: 0, z: 0, 
            duration: 0.8, 
            delay: i * 0.05,
            ease: 'back.out(1.7)' 
          });
        });
      }, null, 1.8);
    }
    
    // Animate loader bar, then trigger warp
    const loadTime = 3000;  // ← Loader fills in 3 seconds
    
    // Track last drawn progress to avoid unnecessary redraws
    let lastDrawnProgress = -1;
    
    gsap.to({ progress: 0 }, {
      progress: 1,
      duration: loadTime / 1000,
      ease: 'power1.inOut',
      onUpdate: function() {
        const p = this.targets()[0].progress;
        
        // Only redraw if visual change (segment or percentage changed)
        // 20 segments = redraw every ~5% change (reduced for performance)
        const visualProgress = Math.floor(p * 100);
        if (visualProgress !== lastDrawnProgress) {
          lastDrawnProgress = visualProgress;
          drawLoaderGraphics(p);
          loaderTexture.needsUpdate = true;
        }
      },
      onComplete: () => {
        triggerWarpIntro();
      }
    });
    // ═══════════════════════════════════════════════════════════════════
    // SECTION SNAP SCROLLER — Threshold-based sticky snapping
    // ═══════════════════════════════════════════════════════════════════
    
    gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);
    gsap.ticker.lagSmoothing(0);
    ScrollTrigger.config({ autoRefreshEvents: 'resize,load' }); // Exclude visibilitychange
    
    // Prevent scroll jumping on browser tab switch (Opera GX fix)
    let savedScrollY = 0;
    let tabSwitching = false;
    
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        savedScrollY = window.scrollY;
        tabSwitching = true;
        gsap.ticker.sleep();
        gsap.killTweensOf(window);
      } else {
        gsap.killTweensOf(window);
        gsap.ticker.wake();
        // Restore scroll position multiple times to fight browser restoration
        window.scrollTo(0, savedScrollY);
        requestAnimationFrame(() => window.scrollTo(0, savedScrollY));
        setTimeout(() => {
          window.scrollTo(0, savedScrollY);
          tabSwitching = false;
        }, 500);
      }
    });
    
    window.addEventListener('blur', () => {
      savedScrollY = window.scrollY;
      tabSwitching = true;
      gsap.killTweensOf(window);
    });
    
    window.addEventListener('focus', () => {
      gsap.killTweensOf(window);
      window.scrollTo(0, savedScrollY);
      requestAnimationFrame(() => window.scrollTo(0, savedScrollY));
      setTimeout(() => {
        window.scrollTo(0, savedScrollY);
        tabSwitching = false;
      }, 500);
    });
    
    // Reset tabSwitching when mouse moves over the page (no click needed)
    document.addEventListener('mousemove', () => {
      if (tabSwitching) {
        tabSwitching = false;
      }
    }, { passive: true });
    
    // Also reset on wheel event (capture phase to run before scroller)
    document.addEventListener('wheel', () => {
      if (tabSwitching) {
        tabSwitching = false;
      }
    }, { passive: true, capture: true });
    
    // Block scroll events during tab switching (Opera GX fix)
    window.addEventListener('scroll', () => {
      if (tabSwitching && Math.abs(window.scrollY - savedScrollY) > 10) {
        window.scrollTo(0, savedScrollY);
      }
    }, { passive: true });
    
    class SectionScroller {
      constructor() {
        this.currentSection = 0;
        this.targetSection = 0;  // Track where we're animating TO
        this.totalSections = 5;
        this.intent = 0;
        this.isAnimating = false;
        this.isActive = false;
        
        // ═══════════════════════════════════════════════════════════════
        // JUNNI-STYLE TUNING - Snappy but smooth
        // ═══════════════════════════════════════════════════════════════
        this.threshold = 0.08;        // Lower = more responsive
        this.intentDecay = 0.92;      // Slower decay = more momentum feel
        this.decayPause = 50;         // Shorter pause before decay starts
        
        // Velocity tracking for adaptive speed
        this.velocity = 0;
        this.lastDelta = 0;
        this.lastWheelTime = 0;
        this.scrollTimeout = null;
        
        this.init();
        
        setTimeout(() => {
          this.isActive = true;
        }, 100);
        
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            this.isActive = false;
            this.intent = 0;
            this.velocity = 0;
          } else {
            this.intent = 0;
            this.velocity = 0;
            this.isAnimating = false;
            setTimeout(() => {
              this.isActive = true;
            }, 300);
          }
        });
        
        window.addEventListener('blur', () => {
          this.isActive = false;
          this.intent = 0;
          this.velocity = 0;
        });
        window.addEventListener('focus', () => {
          this.intent = 0;
          this.velocity = 0;
          this.isAnimating = false;
          setTimeout(() => {
            this.isActive = true;
          }, 300);
        });
      }
      
      init() {
        window.addEventListener('wheel', e => {
          e.preventDefault();
          if (!this.isActive || this.isAnimating || tabSwitching) return;
          
          const now = Date.now();
          const timeDelta = now - this.lastWheelTime;
          this.lastWheelTime = now;
          STATE.isScrolling = true;
          
          clearTimeout(this.scrollTimeout);
          this.scrollTimeout = setTimeout(() => {
            STATE.isScrolling = false;
            this.velocity = 0;
          }, 150);
          
          // Normalize wheel delta
          let delta = e.deltaY;
          if (e.deltaMode === 1) delta *= 30;
          else if (e.deltaMode === 2) delta *= 800;
          
          const normalizedDelta = delta / 100;
          
          // Track velocity for adaptive animation speed
          if (timeDelta > 0 && timeDelta < 100) {
            this.velocity = Math.abs(normalizedDelta) / (timeDelta / 16.67);
            this.velocity = Math.min(this.velocity, 3); // Cap velocity
          }
          
          // Smoother intent accumulation with velocity influence
          const contribution = Math.sign(normalizedDelta) * Math.min(Math.abs(normalizedDelta) * 0.12, 0.15);
          this.intent += contribution;
          this.intent = Math.max(-0.4, Math.min(0.4, this.intent));
          
          this.lastDelta = normalizedDelta;
          this.checkThreshold();
        }, { passive: false });
        
        let touchY = 0;
        let touchStartTime = 0;
        
        window.addEventListener('touchstart', e => {
          touchY = e.touches[0].clientY;
          touchStartTime = Date.now();
          this.intent = 0;
          this.velocity = 0;
        }, { passive: false });
        
        window.addEventListener('touchmove', e => {
          e.preventDefault();
          if (!this.isActive || this.isAnimating || tabSwitching) return;
          STATE.isScrolling = true;
          
          const currentY = e.touches[0].clientY;
          const delta = touchY - currentY;
          const now = Date.now();
          const timeDelta = now - touchStartTime;
          
          // Track touch velocity
          if (timeDelta > 0) {
            this.velocity = Math.abs(delta) / timeDelta * 10;
            this.velocity = Math.min(this.velocity, 3);
          }
          
          touchY = currentY;
          touchStartTime = now;
          
          this.intent += delta * 0.002;
          this.intent = Math.max(-0.4, Math.min(0.4, this.intent));
          this.checkThreshold();
        }, { passive: false });
        
        window.addEventListener('touchend', () => {
          STATE.isScrolling = false;
          if (!this.isAnimating && Math.abs(this.intent) < this.threshold) {
            this.intent = 0;
          }
          this.velocity = 0;
        });
        
        this.decayLoop();
      }
      
      checkThreshold() {
        if (!this.isActive || this.isAnimating || tabSwitching) return;
        
        const scrollPos = window.scrollY;
        const maxScroll = document.body.scrollHeight - window.innerHeight;
        const sectionHeight = maxScroll / (this.totalSections - 1);
        this.currentSection = Math.round(scrollPos / sectionHeight);
        this.currentSection = Math.max(0, Math.min(this.currentSection, this.totalSections - 1));
        
        if (this.currentSection === 0 && this.intent < 0) {
          this.intent = 0;
          return;
        }
        if (this.currentSection === this.totalSections - 1 && this.intent > 0) {
          this.intent = 0;
          return;
        }
        
        if (this.intent > this.threshold && this.currentSection < this.totalSections - 1) {
          this.goToSection(this.currentSection + 1);
        } else if (this.intent < -this.threshold && this.currentSection > 0) {
          this.goToSection(this.currentSection - 1);
        }
      }
      
      goToSection(index) {
        if (this.isAnimating || index === this.currentSection || tabSwitching) return;
        if (index < 0 || index >= this.totalSections) return;
        
        this.isAnimating = true;
        this.intent = 0;
        this.targetSection = index;  // Track where we're going immediately
        STATE.isScrolling = true;
        STATE.isAnimating = true;
        
        const from = this.currentSection;
        const to = index;
        const direction = to > from ? 'down' : 'up';
        const targetScroll = (index / (this.totalSections - 1)) * 
          (document.body.scrollHeight - window.innerHeight);
        
        // ═══════════════════════════════════════════════════════════════
        // JUNNI-STYLE ADAPTIVE TIMING
        // Fast scroll = faster transition, slow scroll = normal transition
        // ═══════════════════════════════════════════════════════════════
        const sectionDistance = Math.abs(to - from);
        let baseDuration = CINEMA.scrollBase + (sectionDistance - 1) * CINEMA.scrollPerSection;
        
        // Velocity modifier: faster scroll = shorter duration (min 0.6s)
        const velocityMod = Math.max(0.5, 1 - this.velocity * 0.15);
        const duration = Math.max(0.6, baseDuration * velocityMod);
        
        // ═══════════════════════════════════════════════════════════════
        // JUNNI-STYLE CUSTOM EASING
        // Exponential ease-out: fast start, smooth landing
        // ═══════════════════════════════════════════════════════════════
        gsap.to(window, {
          scrollTo: { y: targetScroll, autoKill: false },
          duration: duration,
          ease: "expo.out",  // The Junni secret: exponential ease-out
          onComplete: () => {
            this.currentSection = index;
            this.isAnimating = false;
            STATE.isScrolling = false;
            STATE.isAnimating = false;
            this.velocity = 0;
          }
        });
        
        // ═══════════════════════════════════════════════════════════════
        // CINEMATIC CHOREOGRAPHY - Everything moves as ONE
        // Like connected by invisible strings - all elements flow together
        // Tiny stagger (0.04s) just adds organic feel, not sequencing
        // ═══════════════════════════════════════════════════════════════
        
        const sections = ['#hero', '#about', '#extensions', '#templates', '#contact'];
        const fromSection = sections[from];
        const toSection = sections[to];
        
        // Direction: scroll DOWN = content exits UP, enters from BELOW
        const exitY = direction === 'down' ? -CINEMA.yDistance : CINEMA.yDistance;
        const enterY = direction === 'down' ? CINEMA.yDistance : -CINEMA.yDistance;
        
        // ─────────────────────────────────────────────────────────────────
        // EXIT CURRENT SECTION - Everything leaves TOGETHER
        // ─────────────────────────────────────────────────────────────────
        
        // Kill ALL tweens first
        gsap.killTweensOf([
          `${fromSection} .panel-content`,
          `${fromSection} .panel-tag`,
          `${fromSection} h1`, `${fromSection} h2`,
          `${fromSection} p`,
          `${fromSection} .hero-ctas`,
          `${fromSection} .cta-btn`,
          `${fromSection} .about-secondary`,
          '.founder-card',
          '.work-grid',
          '.work-item',
          '.process-card',
          '.process-phone-area'
        ]);
        
        // Collect ALL elements that need to exit
        const exitElements = [
          `${fromSection} .panel-tag`,
          `${fromSection} h1`,
          `${fromSection} h2`, 
          `${fromSection} p`
        ];
        
        // Add section-specific elements
        if (from === 0) exitElements.push(`${fromSection} .hero-ctas`);
        if (from === 1) exitElements.push('.founder-card', `${fromSection} .about-secondary`);
        if (from === 4) {
          exitElements.push(`${fromSection} .contact-glass-bubble`, `${fromSection} .cta-btn`);
          // 🌈 Disable rainbow glow when leaving Contact - match enter timing (reversed)
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uGlowIntensity);
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uRainbowMode);
          // Rainbow mode fades first
          gsap.to(bgPlaneMaterial.uniforms.uRainbowMode, {
            value: 0.0,
            duration: CINEMA.duration * 0.8,
            ease: CINEMA.easeOut
          });
          // Intensity fades slightly after
          gsap.to(bgPlaneMaterial.uniforms.uGlowIntensity, {
            value: 0.0,
            duration: CINEMA.duration,
            ease: CINEMA.easeOut
          });
        }
        
        // EXIT: All elements animate TOGETHER with tiny stagger
        gsap.to(exitElements.join(', '), {
          y: exitY,
          opacity: 0,
          duration: CINEMA.duration,
          ease: CINEMA.easeOut,
          stagger: 0.04  // Tiny stagger for organic feel
        });
        
        // Work items exit together
        if (from === 2) {
          gsap.to('.work-item', {
            y: exitY,
            opacity: 0,
            duration: CINEMA.duration,
            ease: CINEMA.easeOut,
            stagger: 0.03  // Even tighter for grid items
          });
        }
        
        // Process section elements exit together
        if (from === 3) {
          gsap.to('.process-card', {
            yPercent: -50,
            y: exitY,
            opacity: 0,
            visibility: 'hidden',
            duration: CINEMA.duration,
            ease: CINEMA.easeOut,
            stagger: 0.03
          });
          gsap.to('.process-phone-area', {
            y: exitY,
            opacity: 0,
            visibility: 'hidden',
            duration: CINEMA.duration,
            ease: CINEMA.easeOut
          });
        }
        
        // Container fades - skip for #templates (no .panel-content)
        if (fromSection !== '#templates') {
          gsap.to(`${fromSection} .panel-content`, {
            opacity: 0,
            visibility: 'hidden',
            duration: CINEMA.duration * 0.8,
            ease: CINEMA.easeOut
          });
        }
        
        // ─────────────────────────────────────────────────────────────────
        // ENTER NEW SECTION - Everything arrives TOGETHER
        // ─────────────────────────────────────────────────────────────────
        
        const enterDelay = duration * 0.35;  // Start entering at 35% of scroll
        
        // Kill tweens on entering section
        gsap.killTweensOf([
          `${toSection} .panel-content`,
          `${toSection} .panel-tag`,
          `${toSection} h1`, `${toSection} h2`,
          `${toSection} p`,
          `${toSection} .hero-ctas`,
          `${toSection} .cta-btn`,
          `${toSection} .about-secondary`
        ]);
        
        // Set ALL starting positions - same Y offset for everything
        const enterElements = [
          `${toSection} .panel-tag`,
          `${toSection} h1`,
          `${toSection} h2`,
          `${toSection} p`
        ];
        
        // Add section-specific elements
        if (to === 0) enterElements.push(`${toSection} .hero-ctas`);
        if (to === 1) enterElements.push('.founder-card', `${toSection} .about-secondary`);
        if (to === 4) {
          enterElements.push(`${toSection} .contact-glass-bubble`, `${toSection} .cta-btn`);
          // 🌈 Enable rainbow glow when entering Contact - smooth transition
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uGlowIntensity);
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uRainbowMode);
          gsap.to(bgPlaneMaterial.uniforms.uGlowIntensity, {
            value: 1.0,
            duration: CINEMA.duration,
            delay: enterDelay,
            ease: CINEMA.ease
          });
          gsap.to(bgPlaneMaterial.uniforms.uRainbowMode, {
            value: 1.0,
            duration: CINEMA.duration * 0.8,
            delay: enterDelay,
            ease: CINEMA.ease
          });
        }
        
        // Set starting positions - skip for #templates (no .panel-content)
        if (toSection !== '#templates') {
          gsap.set(`${toSection} .panel-content`, { opacity: 0 });
        }
        gsap.set(enterElements.join(', '), { y: enterY, opacity: 0 });
        
        // Hero section needs filter reset (blur was set during intro)
        if (to === 0) {
          gsap.set('#hero .panel-tag, #hero h1, #hero p, #hero .hero-ctas', { filter: 'blur(0px)' });
        }
        
        // Work items setup
        if (to === 2) {
          gsap.killTweensOf('.work-grid');
          gsap.killTweensOf('.work-item');
          gsap.set('.work-grid', { opacity: 0 });
          gsap.set('.work-item', { y: enterY, opacity: 0 });
        }
        
        // Process section setup
        if (to === 3) {
          gsap.killTweensOf('.process-card-left');
          gsap.killTweensOf('.process-card-right');
          gsap.killTweensOf('.process-phone-area');
          // Use yPercent: -50 to maintain vertical centering, y for animation offset
          gsap.set('.process-card-left', { yPercent: -50, y: enterY, opacity: 0, visibility: 'hidden' });
          gsap.set('.process-card-right', { yPercent: -50, y: enterY, opacity: 0, visibility: 'hidden' });
          gsap.set('.process-phone-area', { y: enterY * 0.5, opacity: 0, visibility: 'hidden' });
        }
        
        // ENTER: Container visible first - skip for #templates (no .panel-content)
        if (toSection !== '#templates') {
          gsap.to(`${toSection} .panel-content`, {
            opacity: 1,
            visibility: 'visible',
            duration: CINEMA.duration * 0.5,
            delay: enterDelay,
            ease: CINEMA.ease
          });
        }
        
        // ENTER: All elements animate TOGETHER with tiny stagger
        gsap.to(enterElements.join(', '), {
          y: 0,
          opacity: 1,
          visibility: 'visible',
          duration: CINEMA.duration,
          delay: enterDelay,
          ease: CINEMA.ease,
          stagger: 0.04  // Tiny stagger for organic feel
        });
        
        // Work items enter together
        if (to === 2) {
          gsap.to('.work-grid', {
            opacity: 1,
            duration: CINEMA.duration * 0.5,
            delay: enterDelay,
            ease: CINEMA.ease
          });
          gsap.to('.work-item', {
            y: 0,
            opacity: 1,
            duration: CINEMA.duration,
            delay: enterDelay + 0.1,  // Slight delay after text starts
            ease: CINEMA.ease,
            stagger: 0.04  // Tight stagger
          });
        }
        
        // Process section elements enter together
        if (to === 3) {
          // Left card enters first, right card with slight delay
          // yPercent: -50 maintains vertical centering, y: 0 is the animation target
          gsap.to('.process-card-left', {
            yPercent: -50,
            y: 0,
            opacity: 1,
            visibility: 'visible',
            duration: CINEMA.duration,
            delay: enterDelay,
            ease: CINEMA.ease
          });
          gsap.to('.process-card-right', {
            yPercent: -50,
            y: 0,
            opacity: 1,
            visibility: 'visible',
            duration: CINEMA.duration,
            delay: enterDelay + 0.15,
            ease: CINEMA.ease
          });
          gsap.to('.process-phone-area', {
            y: 0,
            opacity: 1,
            visibility: 'visible',
            duration: CINEMA.duration,
            delay: enterDelay + 0.08,
            ease: CINEMA.ease
          });
        }
        
        // ═══════════════════════════════════════════════════════════════
        // LOGO ANIMATION - Simple up/down with the balls
        // ═══════════════════════════════════════════════════════════════
        
        if (MODELS.logo) {
          gsap.killTweensOf(MODELS.logo.position);
          gsap.killTweensOf(MODELS.logo.scale);
          gsap.killTweensOf(MODELS.logo.rotation);
          
          // Reset interaction state
          logoInteraction.isHovering = false;
          logoInteraction.velocityX = 0;
          logoInteraction.velocityY = 0;
          logoPullTarget.x = 0;
          logoPullTarget.y = 0;
          logoPullCurrent.x = 0;
          logoPullCurrent.y = 0;
          
          if (from === 0 && to > 0) {
            // Leaving Hero - logo exits UPWARD (like the balls)
            gsap.to(MODELS.logo.position, {
              y: 15,
              duration: 0.6,
              ease: 'power2.in',
              onComplete: () => {
                MODELS.logo.visible = false;
              }
            });
          } else if (from > 0 && to === 0) {
            // Returning to Hero - logo enters from ABOVE
            // Use mobile-aware scale and position
            const logoScale = isMobile ? 1.6 : 3;
            const logoY = isMobile ? 0.5 : 0;
            
            MODELS.logo.visible = true;
            MODELS.logo.position.set(0, 15, -5);
            MODELS.logo.scale.setScalar(logoScale);
            MODELS.logo.rotation.set(0, 0, 0);
            MODEL_BASE_Y.logo = logoY;
            
            gsap.to(MODELS.logo.position, {
              y: logoY,
              duration: CINEMA.duration,
              delay: duration * 0.3,
              ease: 'power3.out'
            });
          }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // BACKGROUND ZOOM (Sacred - unchanged)
        // Contact section keeps bgPlane visible for rainbow glow
        // ═══════════════════════════════════════════════════════════════
        
        // 🤖 CONTACT ROBOT - Show/hide when entering/leaving Contact
        if (contactRobot) {
          gsap.killTweensOf(contactRobot.position);
          gsap.killTweensOf(contactRobot.rotation);
          gsap.killTweensOf(contactRobot.scale);
          
          if (to === 4 && from !== 4) {
            // Entering Contact - robot rises from well below screen
            contactRobot.visible = true;
            contactRobot.position.set(0, -20, -5);
            contactRobot.scale.setScalar(5.4);
            contactRobot.rotation.set(0, 0, 0);
            
            // Reset pull state for fresh interaction
            robotPullTarget.x = 0;
            robotPullTarget.y = 0;
            robotPullCurrent.x = 0;
            robotPullCurrent.y = 0;
            
            gsap.to(contactRobot.position, {
              y: -4.0,
              duration: CINEMA.duration * 1.2,
              delay: enterDelay,
              ease: CINEMA.ease
            });
          } else if (from === 4 && to !== 4) {
            // Leaving Contact - robot exits well below screen
            gsap.to(contactRobot.position, {
              y: -20,
              duration: CINEMA.duration * 1.2,
              ease: CINEMA.easeOut,
              onComplete: () => { contactRobot.visible = false; }
            });
          }
        }
        
        gsap.killTweensOf(camera.position);
        gsap.killTweensOf(perspGridMaterial.uniforms.uCurve);
        gsap.killTweensOf(bgPlane.scale);
        
        if (from === 0 && to > 0 && to !== 4) {
          gsap.to(camera.position, { z: 9, duration: duration * 1.2, ease: 'power1.inOut' });
        } else if (from === 0 && to === 4) {
          gsap.to(camera.position, { z: 0.5, duration: duration * 1.2, ease: 'power1.inOut' });
          gsap.to(perspGridMaterial.uniforms.uCurve, { value: 0, duration: duration * 1.2, ease: 'power1.inOut' });
          // Keep bgPlane at full scale for rainbow glow
          gsap.to(bgPlane.scale, { x: 1, y: 1, duration: duration * 1.2, ease: 'power1.inOut' });
        } else if (from > 0 && to === 0) {
          gsap.to(camera.position, { z: 3.5, duration: duration * 1.2, ease: 'power1.inOut' });
          gsap.to(perspGridMaterial.uniforms.uCurve, { value: 7, duration: duration * 0.8, ease: 'power1.inOut' });
          if (from === 4) {
            gsap.to(bgPlane.scale, { x: 1, y: 1, duration: duration * 1.2, ease: 'power1.inOut' });
          }
        }
        
        if (to === 4 && from !== 0) {
          gsap.to(camera.position, { z: 0.5, duration: duration, ease: 'power2.inOut' });
          gsap.to(perspGridMaterial.uniforms.uCurve, { value: 0, duration: duration, ease: 'power2.inOut' });
          // Keep bgPlane at full scale for rainbow glow
          gsap.to(bgPlane.scale, { x: 1, y: 1, duration: duration, ease: 'power2.inOut' });
        } else if (from === 4 && to !== 0) {
          gsap.to(camera.position, { z: 9, duration: duration, ease: 'power2.inOut' });
          gsap.to(perspGridMaterial.uniforms.uCurve, { value: 7, duration: duration, ease: 'power2.inOut' });
          gsap.to(bgPlane.scale, { x: 1, y: 1, duration: duration, ease: 'power2.inOut' });
        } else if (from === 4 && to === 0) {
          gsap.to(perspGridMaterial.uniforms.uCurve, { value: 7, duration: duration * 0.6, ease: 'power2.out' });
        }
      }
      
      decayLoop() {
        requestAnimationFrame(() => this.decayLoop());
        if (tabSwitching) return;
        const timeSinceWheel = Date.now() - this.lastWheelTime;
        if (timeSinceWheel < this.decayPause) return;
        if (!this.isAnimating && Math.abs(this.intent) > 0.001) {
          this.intent *= this.intentDecay;
        }
      }
    }
    
    let scroller = null;
    
    // ═══════════════════════════════════════════════════════════════════
    // SCROLL ANIMATIONS
    // ═══════════════════════════════════════════════════════════════════
    
    function initScrollAnimations() {
      // Create scroller now that we're ready
      scroller = new SectionScroller();
      
      gsap.registerPlugin(ScrollTrigger);
      
      const dots = document.querySelectorAll('.progress-dot');
      
      // ─────────────────────────────────────────────────────────────────
      // RESET FUNCTIONS
      // ─────────────────────────────────────────────────────────────────
      
      function resetExtModels() {
        ['wand', 'bolt', 'shield', 'eyedrop'].forEach(name => {
          const m = MODELS[name];
          if (m) {
            m.visible = false;
            m.position.set(8, 0, 0);
            m.rotation.set(0, 2, 0);
            MODEL_BASE_Y[name] = 0;
          }
        });
      }
      
      function resetTemplateModels() {
        ['phone', 'tablet', 'laptop'].forEach(name => {
          const m = MODELS[name];
          if (m) {
            m.visible = false;
            m.position.set(10, 0, 0);
            m.rotation.set(0, 1.5, 0);
            MODEL_BASE_Y[name] = 0;
          }
        });
      }
      
      function setActiveSection(i) {
        STATE.section = i;
        dots.forEach((d, idx) => d.classList.toggle('active', idx === i));
      }
      
      // ─────────────────────────────────────────────────────────────────
      // HERO - Parallax effects + DNA early trigger
      // Text animations handled by warp intro and goToSection()
      // ─────────────────────────────────────────────────────────────────
      
      const heroElementsBase = { textZ: -8 };
      let dnaTriggered = false;
      let lastHeroProgress = 0;
      
      ScrollTrigger.create({
        trigger: '#hero',
        start: 'top top',
        end: '+=100%',
        pin: true,
        scrub: true,
        onUpdate: self => {
          const p = self.progress;
          const scrollingDown = p > lastHeroProgress;
          
          // Parallax: text plane moves with scroll
          heroScrollOffset.textY = p * 8;
          heroTextPlane.position.z = heroElementsBase.textZ + p * 2;
          
          // Parallax: floating balls move up with varied speeds
          floatingBalls.forEach((ball, i) => {
            const speedMultiplier = 1 + (i * 0.15);
            ball.userData.scrollOffsetY = p * 10 * speedMultiplier;
          });
          
          // DNA enters early (60% through hero scroll, only when scrolling down)
          // Enters from BELOW - pure Y translation at full scale for cinematic flow
          if (p > 0.6 && scrollingDown && !dnaTriggered && dnaHelix) {
            dnaTriggered = true;
            
            // Kill any existing DNA tweens to prevent conflicts
            gsap.killTweensOf(dnaHelix.position);
            gsap.killTweensOf(dnaHelix.scale);
            
            dnaHelix.visible = true;
            
            // Start well below viewport at FULL scale - no zoom, just rise
            // Position: moved right 0.5 units, final y=-0.1 (10px down)
            // Mobile: use smaller scale
            const dnaAnimScale = isMobile ? 4.0 : 6.5;
            dnaHelix.position.set(-0.5, -12, -8);
            dnaHelix.scale.setScalar(dnaAnimScale);
            
            gsap.to(dnaHelix.position, {
              y: -0.1,
              duration: CINEMA.duration * 1.2,
              ease: CINEMA.ease
            });
          }
          
          lastHeroProgress = p;
        },
        onEnter: () => {
          setActiveSection(0);
          resetExtModels();
          resetTemplateModels();
        },
        onEnterBack: () => {
          setActiveSection(0);
          // Logo animation handled by goToSection
          resetExtModels();
          resetTemplateModels();
          dnaTriggered = false;
          lastHeroProgress = 1;
        }
      });
      
      // ─────────────────────────────────────────────────────────────────
      // ABOUT - 3D elements (neurons, DNA)
      // Animate on Y axis to match text flow - enter from below, exit up
      // ─────────────────────────────────────────────────────────────────
      
      ScrollTrigger.create({
        trigger: '#about',
        start: 'top top',
        end: '+=100%',
        pin: true,
        scrub: true,
        onEnter: () => {
          setActiveSection(1);
          floatingBalls.forEach(ball => { ball.visible = false; });
          
          // Neurons enter from BELOW (Y axis) at full scale - no zoom, pure slide
          floatingNeurons.forEach((neuron, i) => {
            // Kill any existing tweens first
            gsap.killTweensOf(neuron.position);
            gsap.killTweensOf(neuron.scale);
            
            neuron.visible = true;
            // Start well below viewport at FULL scale
            neuron.position.set(neuron.userData.baseX, neuron.userData.baseY - 15, neuron.userData.baseZ);
            neuron.scale.setScalar(neuron.userData.baseScale);  // Full scale from start
            
            gsap.to(neuron.position, {
              y: neuron.userData.baseY,
              duration: CINEMA.duration * 1.1,
              delay: i * 0.04,
              ease: CINEMA.ease
            });
          });
          
          // DNA should already be visible from Hero scroll trigger
        },
        onLeave: () => {
          // Kill existing tweens to prevent conflicts
          floatingNeurons.forEach(neuron => {
            gsap.killTweensOf(neuron.position);
            gsap.killTweensOf(neuron.scale);
          });
          if (dnaHelix) {
            gsap.killTweensOf(dnaHelix.position);
            gsap.killTweensOf(dnaHelix.scale);
          }
          
          // Neurons exit UPWARD - smooth like the logo
          floatingNeurons.forEach((neuron) => {
            gsap.to(neuron.position, {
              y: 20,  // All go to same high Y (off screen top)
              duration: 0.8,
              ease: 'power2.in',
              onComplete: () => {
                neuron.visible = false;
              }
            });
          });
          
          // DNA exits UPWARD - smooth exit
          if (dnaHelix && dnaHelix.visible) {
            gsap.to(dnaHelix.position, {
              y: 20,
              duration: 0.8,
              ease: 'power2.in',
              onComplete: () => {
                if (dnaHelix) dnaHelix.visible = false;
              }
            });
          }
        },
        onLeaveBack: () => {
          floatingBalls.forEach(ball => { ball.visible = true; });
          
          // Kill existing tweens to prevent conflicts
          floatingNeurons.forEach(neuron => {
            gsap.killTweensOf(neuron.position);
            gsap.killTweensOf(neuron.scale);
          });
          if (dnaHelix) {
            gsap.killTweensOf(dnaHelix.position);
            gsap.killTweensOf(dnaHelix.scale);
          }
          
          // Neurons exit DOWNWARD - smooth like logo
          floatingNeurons.forEach((neuron) => {
            gsap.to(neuron.position, {
              y: -15,  // All go to same low Y (off screen bottom)
              duration: 0.8,
              ease: 'power2.in',
              onComplete: () => {
                neuron.visible = false;
              }
            });
          });
          
          // DNA exits DOWNWARD - smooth exit
          if (dnaHelix && dnaHelix.visible) {
            gsap.to(dnaHelix.position, {
              y: -15,
              duration: 0.8,
              ease: 'power2.in',
              onComplete: () => {
                if (dnaHelix) dnaHelix.visible = false;
              }
            });
          }
        },
        onEnterBack: () => {
          setActiveSection(1);
          resetExtModels();
          
          // Kill existing tweens to prevent conflicts
          if (dnaHelix) {
            gsap.killTweensOf(dnaHelix.position);
            gsap.killTweensOf(dnaHelix.scale);
          }
          floatingNeurons.forEach(neuron => {
            gsap.killTweensOf(neuron.position);
            gsap.killTweensOf(neuron.scale);
          });
          
          // DNA enters from ABOVE (coming back from Work) - no zoom, pure slide
          if (dnaHelix) {
            const dnaAnimScale = isMobile ? 4.0 : 6.5;
            dnaHelix.visible = true;
            dnaHelix.position.set(-0.5, 18, -8);  // Start well above viewport, same x as final
            dnaHelix.scale.setScalar(dnaAnimScale);  // Mobile-aware scale
            
            gsap.to(dnaHelix.position, {
              y: -0.1,  // Same final y position
              duration: CINEMA.duration * 1.1,
              ease: CINEMA.ease
            });
          }
          
          // Neurons enter from ABOVE (coming back from Work) - no zoom, pure slide
          floatingNeurons.forEach((neuron, i) => {
            neuron.visible = true;
            neuron.position.set(neuron.userData.baseX, neuron.userData.baseY + 20, neuron.userData.baseZ);
            neuron.scale.setScalar(neuron.userData.baseScale);  // Full scale from start
            
            gsap.to(neuron.position, {
              y: neuron.userData.baseY,
              duration: CINEMA.duration * 1.1,
              delay: i * 0.04,
              ease: CINEMA.ease
            });
          });
        }
      });
      
      // ─────────────────────────────────────────────────────────────────
      // WORK (Extensions) - Heat particles animation
      // ─────────────────────────────────────────────────────────────────
      
      ScrollTrigger.create({
        trigger: '#extensions',
        start: 'top top',
        end: '+=150%',
        pin: true,
        scrub: true,
        onEnter: () => {
          setActiveSection(2);
          // Don't hide neurons here - About's onLeave animation handles it
          floatingBalls.forEach(b => { b.visible = false; });
          resetExtModels();
          
          // Show heat particles and fade in
          heatParticles.visible = true;
          gsap.to(heatParticleMaterial.uniforms.uOpacity, {
            value: 1,
            duration: 1.2,
            ease: 'power2.out'
          });
        },
        onLeave: () => {
          // Fade out heat particles
          gsap.to(heatParticleMaterial.uniforms.uOpacity, {
            value: 0,
            duration: 0.6,
            ease: 'power2.in',
            onComplete: () => { heatParticles.visible = false; }
          });
        },
        onLeaveBack: () => {
          // Fade out heat particles
          gsap.to(heatParticleMaterial.uniforms.uOpacity, {
            value: 0,
            duration: 0.6,
            ease: 'power2.in',
            onComplete: () => { heatParticles.visible = false; }
          });
        },
        onEnterBack: () => {
          setActiveSection(2);
          resetTemplateModels();
          
          // Show heat particles and fade in
          heatParticles.visible = true;
          gsap.to(heatParticleMaterial.uniforms.uOpacity, {
            value: 1,
            duration: 1.2,
            ease: 'power2.out'
          });
        }
      });
      
      // ─────────────────────────────────────────────────────────────────
      // PROCESS (Templates) - Phone model animation
      // ─────────────────────────────────────────────────────────────────
      
      ScrollTrigger.create({
        trigger: '#templates',
        start: 'top top',
        end: '+=150%',
        pin: true,
        scrub: true,
        onEnter: () => {
          setActiveSection(3);
          floatingBalls.forEach(b => { b.visible = false; });
          resetExtModels();
          resetTemplateModels();
          
          // ─────────────────────────────────────────────────────────────────
          // CLEAN PROCESS SECTION - Code bracket + animated timeline
          // On mobile: Show code bracket scaled down for nice glass effect
          // ─────────────────────────────────────────────────────────────────
          
          // Code bracket enters from BELOW with slow spin
          if (codeBracket) {
            gsap.killTweensOf(codeBracket.position);
            gsap.killTweensOf(codeBracket.rotation);
            
            codeBracket.visible = true;
            codeBracket.position.set(0, -10, -5);
            // Smaller on mobile
            codeBracket.scale.setScalar(isMobile ? 2.5 : 4.0);
            codeBracket.rotation.set(0, 0, 0);
            
            // Enter animation - rise into position
            // Mobile: slightly above center (y=0.25), Desktop: above center (y=3.95)
            gsap.to(codeBracket.position, {
              y: isMobile ? 0.16 : 3.95,
              duration: CINEMA.duration * 1.2,
              ease: CINEMA.ease
            });
            
            // Slow 360 spin (20 seconds for full rotation)
            gsap.to(codeBracket.rotation, {
              y: Math.PI * 2,
              duration: 20,
              ease: 'none',
              repeat: -1
            });
          }
          
          // Reset timeline state
          gsap.set('.timeline-line-container', { opacity: 1 }); // Show container
          gsap.set('.timeline-line', { width: '0%', opacity: 0 });
          document.querySelectorAll('.process-step').forEach(step => {
            step.classList.remove('dot-active');
          });
          
          // Timeline labels fade in first
          gsap.to('.process-step', {
            opacity: 1, 
            visibility: 'visible', 
            y: 0,
            duration: 0.6, 
            delay: 0.4,
            stagger: 0.1,
            ease: 'power2.out'
          });
          
          // Animate line and dots progressively
          const timelineTl = gsap.timeline({ delay: 0.6 });
          
          // First dot glows immediately
          timelineTl.call(() => {
            document.querySelector('.step-discovery')?.classList.add('dot-active');
          });
          
          // Line grows to 33% (reaches second dot)
          timelineTl.to('.timeline-line', {
            width: '33%',
            opacity: 1,
            duration: 0.5,
            ease: 'power2.inOut'
          });
          timelineTl.call(() => {
            document.querySelector('.step-design')?.classList.add('dot-active');
          });
          
          // Line grows to 66% (reaches third dot)
          timelineTl.to('.timeline-line', {
            width: '66%',
            duration: 0.5,
            ease: 'power2.inOut'
          });
          timelineTl.call(() => {
            document.querySelector('.step-develop')?.classList.add('dot-active');
          });
          
          // Line grows to 100% (reaches fourth dot)
          timelineTl.to('.timeline-line', {
            width: '100%',
            duration: 0.5,
            ease: 'power2.inOut'
          });
          timelineTl.call(() => {
            document.querySelector('.step-deploy')?.classList.add('dot-active');
          });
        },
        onLeave: () => {
          // Code bracket exits UPWARD when going to Contact
          if (codeBracket && codeBracket.visible) {
            gsap.killTweensOf(codeBracket.position);
            gsap.killTweensOf(codeBracket.rotation);
            gsap.to(codeBracket.position, {
              y: 20,
              duration: 0.8,
              ease: 'power2.in',
              onComplete: () => { codeBracket.visible = false; }
            });
          }
          
          // GIF area exits UPWARD
          gsap.to('.process-phone-area', {
            y: -80,
            opacity: 0,
            duration: CINEMA.duration * 0.6,
            ease: 'power2.in'
          });
          
          // Cards exit UPWARD together
          gsap.to('.process-card-left, .process-card-right', {
            y: -80,
            opacity: 0,
            duration: CINEMA.duration * 0.6,
            ease: 'power2.in'
          });
          
          // Hide step labels and reset timeline IMMEDIATELY
          gsap.set('.timeline-line-container', { opacity: 0 });
          gsap.to('.process-step', {
            opacity: 0, visibility: 'hidden', y: -20,
            duration: 0.4, stagger: 0.05
          });
          gsap.to('.timeline-line', { width: '0%', duration: 0.3 });
          document.querySelectorAll('.process-step').forEach(step => {
            step.classList.remove('dot-active');
          });
        },
        onLeaveBack: () => {
          // Code bracket exits DOWNWARD when going back to Work
          if (codeBracket && codeBracket.visible) {
            gsap.killTweensOf(codeBracket.position);
            gsap.killTweensOf(codeBracket.rotation);
            gsap.to(codeBracket.position, {
              y: -15,
              duration: 0.8,
              ease: 'power2.in',
              onComplete: () => { codeBracket.visible = false; }
            });
          }
          
          // Hide step labels and reset timeline IMMEDIATELY
          gsap.set('.timeline-line-container', { opacity: 0 });
          gsap.to('.process-step', {
            opacity: 0, visibility: 'hidden', y: 20,
            duration: 0.4, stagger: 0.05
          });
          gsap.to('.timeline-line', { width: '0%', duration: 0.3 });
          document.querySelectorAll('.process-step').forEach(step => {
            step.classList.remove('dot-active');
          });
        },
        onEnterBack: () => {
          setActiveSection(3);
          
          // ─────────────────────────────────────────────────────────────────
          // ENTER FROM ABOVE (coming back from Contact)
          // ─────────────────────────────────────────────────────────────────
          
          // 🌈 Disable rainbow glow when coming back from Contact - match enter timing (reversed)
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uGlowIntensity);
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uRainbowMode);
          // Rainbow mode fades first (reverse of enter where it fades in after intensity)
          gsap.to(bgPlaneMaterial.uniforms.uRainbowMode, {
            value: 0.0,
            duration: CINEMA.duration * 0.8,
            ease: CINEMA.easeOut
          });
          // Intensity fades slightly after
          gsap.to(bgPlaneMaterial.uniforms.uGlowIntensity, {
            value: 0.0,
            duration: CINEMA.duration,
            ease: CINEMA.easeOut
          });
          
          // Code bracket enters from above with slow spin
          if (codeBracket) {
            gsap.killTweensOf(codeBracket.position);
            gsap.killTweensOf(codeBracket.rotation);
            
            codeBracket.visible = true;
            codeBracket.position.set(0, 20, -5);
            codeBracket.scale.setScalar(isMobile ? 2.5 : 4.0);
            codeBracket.rotation.set(0, 0, 0);
            
            // Enter animation - drop into position
            // Mobile: slightly above center (y=0.25), Desktop: above center (y=3.95)
            gsap.to(codeBracket.position, {
              y: isMobile ? 0.16 : 3.95,
              duration: CINEMA.duration * 1.2,
              ease: 'power2.out'
            });
            
            // Slow 360 spin (20 seconds for full rotation)
            gsap.to(codeBracket.rotation, {
              y: Math.PI * 2,
              duration: 20,
              ease: 'none',
              repeat: -1
            });
          }
          
          // Reset timeline state
          gsap.set('.timeline-line-container', { opacity: 1 }); // Show container
          gsap.set('.timeline-line', { width: '0%', opacity: 0 });
          document.querySelectorAll('.process-step').forEach(step => {
            step.classList.remove('dot-active');
          });
          
          // Timeline labels fade in first
          gsap.to('.process-step', {
            opacity: 1, 
            visibility: 'visible', 
            y: 0,
            duration: 0.6, 
            delay: 0.3,
            stagger: 0.1,
            ease: 'power2.out'
          });
          
          // Animate line and dots progressively
          const timelineTl = gsap.timeline({ delay: 0.5 });
          
          // First dot glows immediately
          timelineTl.call(() => {
            document.querySelector('.step-discovery')?.classList.add('dot-active');
          });
          
          // Line grows to 33%
          timelineTl.to('.timeline-line', {
            width: '33%',
            opacity: 1,
            duration: 0.5,
            ease: 'power2.inOut'
          });
          timelineTl.call(() => {
            document.querySelector('.step-design')?.classList.add('dot-active');
          });
          
          // Line grows to 66%
          timelineTl.to('.timeline-line', {
            width: '66%',
            duration: 0.5,
            ease: 'power2.inOut'
          });
          timelineTl.call(() => {
            document.querySelector('.step-develop')?.classList.add('dot-active');
          });
          
          // Line grows to 100%
          timelineTl.to('.timeline-line', {
            width: '100%',
            duration: 0.5,
            ease: 'power2.inOut'
          });
          timelineTl.call(() => {
            document.querySelector('.step-deploy')?.classList.add('dot-active');
          });
        }
      });
      
      // ─────────────────────────────────────────────────────────────────
      // CONTACT - Robot model + rainbow glow + pinning
      // Text + camera animations handled by goToSection()
      // ─────────────────────────────────────────────────────────────────
      
      ScrollTrigger.create({
        trigger: '#contact',
        start: 'top top',
        end: '+=80%',
        pin: true,
        scrub: true,
        onEnter: () => {
          setActiveSection(4);
          floatingBalls.forEach(b => { b.visible = false; });
          resetTemplateModels();
          
          // Footer bubble slides up from bottom
          gsap.killTweensOf('.footer-glass-bubble');
          gsap.set('.footer-glass-bubble', { y: 80, opacity: 0 });
          gsap.to('.footer-glass-bubble', {
            y: 0,
            opacity: 1,
            duration: 0.6,
            ease: 'power2.out',
            onComplete: () => {
              document.querySelector('.footer-glass-bubble')?.classList.add('visible');
            }
          });
          
          // 🌈 Enable rainbow background glow - smooth transition
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uGlowIntensity);
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uRainbowMode);
          gsap.to(bgPlaneMaterial.uniforms.uGlowIntensity, {
            value: 1.0,
            duration: CINEMA.duration,
            ease: CINEMA.ease
          });
          gsap.to(bgPlaneMaterial.uniforms.uRainbowMode, {
            value: 1.0,
            duration: CINEMA.duration * 0.8,
            ease: CINEMA.ease
          });
          
          // Robot handled by goToSection to avoid conflicts
        },
        onLeaveBack: () => {
          // Footer bubble slides down
          gsap.killTweensOf('.footer-glass-bubble');
          gsap.to('.footer-glass-bubble', {
            y: 80,
            opacity: 0,
            duration: 0.4,
            ease: 'power2.in',
            onComplete: () => {
              document.querySelector('.footer-glass-bubble')?.classList.remove('visible');
            }
          });
          
          // Rainbow glow handled by Process section's onEnterBack to avoid conflicts
          // Robot handled by goToSection to avoid conflicts
        },
        onEnterBack: () => {
          setActiveSection(4);
          
          // Footer bubble slides up from bottom
          gsap.killTweensOf('.footer-glass-bubble');
          gsap.set('.footer-glass-bubble', { y: 80, opacity: 0 });
          gsap.to('.footer-glass-bubble', {
            y: 0,
            opacity: 1,
            duration: 0.6,
            ease: 'power2.out',
            onComplete: () => {
              document.querySelector('.footer-glass-bubble')?.classList.add('visible');
            }
          });
          
          // 🌈 Re-enable rainbow glow - smooth transition
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uGlowIntensity);
          gsap.killTweensOf(bgPlaneMaterial.uniforms.uRainbowMode);
          gsap.to(bgPlaneMaterial.uniforms.uGlowIntensity, {
            value: 1.0,
            duration: CINEMA.duration,
            ease: CINEMA.ease
          });
          gsap.to(bgPlaneMaterial.uniforms.uRainbowMode, {
            value: 1.0,
            duration: CINEMA.duration * 0.8,
            ease: CINEMA.ease
          });
          
          // Robot handled by goToSection to avoid conflicts
        }
      });
      
      // ─────────────────────────────────────────────────────────────────
      // NAV CLICK HANDLERS
      // ─────────────────────────────────────────────────────────────────
      
      const sectionMap = {
        '#hero': 0,
        '#about': 1,
        '#extensions': 2,
        '#templates': 3,
        '#contact': 4
      };
      
      document.querySelectorAll('.nav-links a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const target = link.getAttribute('href');
          const sectionIndex = sectionMap[target];
          if (sectionIndex !== undefined && scroller) {
            scroller.goToSection(sectionIndex);
          }
        });
      });
      
      document.querySelector('nav .logo').addEventListener('click', () => {
        if (scroller && scroller.currentSection !== 4) {
          scroller.goToSection(0);
        }
      });
      
      // Hero CTA click handler
      document.addEventListener('click', (e) => {
        const heroCta = e.target.closest('.hero-ctas .cta-btn');
        if (heroCta && scroller) {
          e.preventDefault();
          e.stopPropagation();
          const target = heroCta.getAttribute('href');
          const sectionIndex = sectionMap[target];
          if (sectionIndex !== undefined) {
            scroller.goToSection(sectionIndex);
          }
        }
      });
      
      // ═══════════════════════════════════════════════════════════════════
      // CONTACT FORM - Supabase Submission
      // ═══════════════════════════════════════════════════════════════════
      
      const contactForm = document.getElementById('contact-form');
      const formError = document.getElementById('form-error');
      const formSuccess = document.getElementById('form-success');
      const submitBtn = document.getElementById('contact-submit');
      
      // 🔧 SUPABASE CONFIG
      const SUPABASE_URL = 'https://gwtcknhqnbaqtrruwreq.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3dGNrbmhxbmJhcXRycnV3cmVxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkwNzA3MDgsImV4cCI6MjA4NDY0NjcwOH0.mOquPPzLcx85B3_9XsAuhIXhE7reVFeXZ0sS7gQqvFM';
      const SUPABASE_TABLE = 'contacts';
      
      if (contactForm) {
        contactForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          
          // Get form data
          const formData = {
            name: document.getElementById('contact-name').value.trim(),
            email: document.getElementById('contact-email').value.trim(),
            project_type: document.getElementById('contact-project').value,
            message: document.getElementById('contact-message').value.trim(),
            created_at: new Date().toISOString()
          };
          
          // Validate
          if (!formData.name || !formData.email || !formData.project_type || !formData.message) {
            formError.textContent = 'Please fill in all fields.';
            formError.classList.add('visible');
            return;
          }
          
          // Hide any previous errors
          formError.classList.remove('visible');
          
          // Disable button and show loading state
          submitBtn.disabled = true;
          submitBtn.querySelector('.btn-text').textContent = 'Sending...';
          
          try {
            // Send to Supabase
            const response = await fetch(`${SUPABASE_URL}/rest/v1/${SUPABASE_TABLE}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'Prefer': 'return=minimal'
              },
              body: JSON.stringify(formData)
            });
            
            if (!response.ok) {
              throw new Error('Failed to submit form');
            }
            
            // Success! Hide form and show success message
            contactForm.style.display = 'none';
            formSuccess.style.display = 'block';
            
            console.log('✅ Contact form submitted successfully');
            
          } catch (error) {
            console.error('❌ Form submission error:', error);
            formError.textContent = 'Something went wrong. Please try again or email build@iterex.dev directly.';
            formError.classList.add('visible');
            
            // Reset button
            submitBtn.disabled = false;
            submitBtn.querySelector('.btn-text').textContent = 'Send Message';
          }
        });
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // CURSOR
    // ═══════════════════════════════════════════════════════════════════
    
    const cursor = document.getElementById('cursor');
    const trails = [
      document.getElementById('cursorTrail1'),
      document.getElementById('cursorTrail2')
    ];
    
    // ASCII cursor characters
    const chars = ['_', '▊', '◈', '◇', '⬡', '▪', '◉', '⬢'];
    const hoverChars = ['▶', '●', '◆', '⬢', '★'];
    const glitchChars = ['#', '@', '!', '%', '&', '*', '█', '▓'];
    
    let tx = 0, ty = 0;
    let cx = 0, cy = 0;
    let isHovering = false;
    let currentCharIndex = 0;
    let glitchInterval = null;
    let trailPositions = [{x: 0, y: 0}, {x: 0, y: 0}];
    
    // Rotate through characters
    setInterval(() => {
      if (!isHovering) {
        currentCharIndex = (currentCharIndex + 1) % chars.length;
        cursor.textContent = chars[currentCharIndex];
      }
    }, 150);
    
    document.addEventListener('mousemove', e => {
      tx = e.clientX;
      ty = e.clientY;
      STATE.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      STATE.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    }, { passive: true });
    
    // Click effect
    document.addEventListener('mousedown', () => {
      cursor.classList.add('clicking');
      cursor.textContent = '×';
    });
    
    document.addEventListener('mouseup', () => {
      cursor.classList.remove('clicking');
    });
    
    // Hover effects with glitch
    function startGlitch() {
      isHovering = true;
      cursor.classList.add('hover');
      
      let glitchCount = 0;
      glitchInterval = setInterval(() => {
        if (glitchCount < 5) {
          cursor.textContent = glitchChars[Math.floor(Math.random() * glitchChars.length)];
          glitchCount++;
        } else {
          cursor.textContent = hoverChars[Math.floor(Math.random() * hoverChars.length)];
        }
      }, 50);
    }
    
    function stopGlitch() {
      isHovering = false;
      cursor.classList.remove('hover');
      if (glitchInterval) {
        clearInterval(glitchInterval);
        glitchInterval = null;
      }
    }
    
    document.querySelectorAll('a, button, .cta-btn, .nav-links span, .work-item, .progress-dot, nav .logo').forEach(el => {
      el.addEventListener('mouseenter', startGlitch);
      el.addEventListener('mouseleave', stopGlitch);
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // 3D PARALLAX TILT EFFECT FOR WORK ITEMS
    // ═══════════════════════════════════════════════════════════════════
    
    document.querySelectorAll('.work-item').forEach(card => {
      const maxTilt = 12; // Max rotation in degrees
      
      card.addEventListener('mousemove', (e) => {
        const rect = card.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Calculate rotation based on mouse position (-1 to 1)
        const rotateY = ((x / rect.width) - 0.5) * 2 * maxTilt;
        const rotateX = ((y / rect.height) - 0.5) * -2 * maxTilt;
        
        card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(-4px)`;
      });
      
      card.addEventListener('mouseleave', () => {
        card.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) translateY(0px)';
      });
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // PERFORMANCE MONITORING
    // ═══════════════════════════════════════════════════════════════════
    let frameCount = 0;
    let lastFPSTime = performance.now();
    let currentFPS = 60;
    
    function updateFPS() {
      frameCount++;
      const now = performance.now();
      if (now - lastFPSTime >= 1000) {
        currentFPS = frameCount;
        frameCount = 0;
        lastFPSTime = now;
        if (currentFPS < 50) {
        }
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // ANIMATION LOOP
    // ═══════════════════════════════════════════════════════════════════
    
    let time = 0;
    let loggedComposerStart = false;
    
    // Frame limiter - cap at 60fps to reduce CPU/GPU load
    let lastFrameTime = 0;
    const targetFPS = 60;
    const frameInterval = 1000 / targetFPS;
    
    function animate(currentTime) {
      requestAnimationFrame(animate);
      
      // Skip frame if not enough time has passed
      const deltaTime = currentTime - lastFrameTime;
      if (deltaTime < frameInterval) return;
      lastFrameTime = currentTime - (deltaTime % frameInterval);
      
      updateFPS();
      time += 0.016;
      
      // Update holo shader - skip during loading for performance
      if (!isLoadingMode) {
        holoUniforms.uTime.value = time;
        holoUniforms.uMouse.value.set(STATE.mouse.x * 0.5 + 0.5, STATE.mouse.y * 0.5 + 0.5);
        
        // Update rainbow robot material (only when visible)
        if (contactRobot && contactRobot.visible && contactRobot.userData.rainbowMat) {
          contactRobot.userData.rainbowMat.uniforms.uTime.value = time;
        }
        
        // Update heat particles (only when visible in Work section)
        if (heatParticles && heatParticles.visible) {
          heatParticleMaterial.uniforms.uTime.value = time;
        }
      }
      
      // Update background - skip during loading for performance
      if (!isLoadingMode) {
        perspGridMaterial.uniforms.uTime.value = time;
        // Lerp toward mouse without creating new Vector2 every frame
        const targetX = STATE.mouse.x;
        const targetY = STATE.mouse.y;
        perspGridMaterial.uniforms.uMouse.value.x += (targetX - perspGridMaterial.uniforms.uMouse.value.x) * 0.04;
        perspGridMaterial.uniforms.uMouse.value.y += (targetY - perspGridMaterial.uniforms.uMouse.value.y) * 0.04;
        bgPlaneMaterial.uniforms.uTime.value = time;
      }
      
      // Rotate loader brain - only during loading mode
      if (isLoadingMode && loaderBrain) {
        // Calculate target rotation from mouse (clamped to max)
        brainTarget.x = Math.max(-brainMaxRotation, Math.min(brainMaxRotation, -brainMouse.y * 0.4));
        brainTarget.y = Math.max(-brainMaxRotation, Math.min(brainMaxRotation, brainMouse.x * 0.5));
        
        // Lerp current toward target with friction
        brainCurrent.x += (brainTarget.x - brainCurrent.x) * brainFriction;
        brainCurrent.y += (brainTarget.y - brainCurrent.y) * brainFriction;
        
        // Apply rotation + subtle ambient motion layered on top
        loaderBrain.rotation.x = -brainCurrent.x + Math.sin(time * 0.3) * 0.05;
        loaderBrain.rotation.y = brainCurrent.y + Math.sin(time * 0.5) * 0.08;
      }
      
      // Subtle glow pulse - only during loading
      if (isLoadingMode && brainGlow) {
        brainGlow.material.opacity = 0.8 + Math.sin(time * 2) * 0.2;
      }
      
      // Render background to refraction texture (for logo glass material)
      // ONLY run in Hero section - not needed elsewhere and causes robot flicker
      if (!isLoadingMode && heroLogo && STATE.section === 0 && !isMobile) {
        // Hide logo and glow for background capture
        heroLogo.visible = false;
        if (heroLogo.userData.glow) heroLogo.userData.glow.visible = false;
        
        renderer.setRenderTarget(refractionRT);
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);
        
        // Restore visibility
        heroLogo.visible = true;
        if (heroLogo.userData.glow) heroLogo.userData.glow.visible = true;
      }
      
      // Hero logo - smooth pull effect (follows mouse like brain loader)
      // Skip during loading, transitions, and scrolling
      if (!isLoadingMode && heroLogo && STATE.section === 0 && !STATE.isAnimating && !STATE.isScrolling) {
        // Pull effect - logo tilts toward mouse position
        logoPullTarget.x = -logoMouse.y * logoPullStrength;
        logoPullTarget.y = logoMouse.x * logoPullStrength;
        
        // Smoothly lerp current toward target with friction
        logoPullCurrent.x += (logoPullTarget.x - logoPullCurrent.x) * logoPullFriction;
        logoPullCurrent.y += (logoPullTarget.y - logoPullCurrent.y) * logoPullFriction;
        
        // Apply smooth pull rotation
        heroLogo.rotation.x = logoPullCurrent.x;
        heroLogo.rotation.y = logoPullCurrent.y;
      }
      
      // Contact robot - same pull effect as logo
      if (!isLoadingMode && contactRobot && contactRobot.visible && STATE.section === 4 && !STATE.isAnimating && !STATE.isScrolling) {
        // Pull effect - robot tilts toward mouse position
        robotPullTarget.x = -robotMouse.y * robotPullStrength;
        robotPullTarget.y = robotMouse.x * robotPullStrength;
        
        // Smoothly lerp current toward target with friction
        robotPullCurrent.x += (robotPullTarget.x - robotPullCurrent.x) * robotPullFriction;
        robotPullCurrent.y += (robotPullTarget.y - robotPullCurrent.y) * robotPullFriction;
        
        // Apply smooth pull rotation
        contactRobot.rotation.x = robotPullCurrent.x;
        contactRobot.rotation.y = robotPullCurrent.y;
      }
      
      // Animate the glow shader (color wave) - runs in all sections
      if (!isLoadingMode && heroLogo && heroLogo.userData.glowMaterial) {
        // Track scroll velocity
        STATE.scrollY = window.scrollY;
        STATE.scrollVelocity = Math.abs(STATE.scrollY - STATE.lastScrollY);
        STATE.lastScrollY = STATE.scrollY;
        
        // If scrolling, immediately boost speed
        if (STATE.scrollVelocity > 0.5) {
          // Direct boost - more responsive
          STATE.glowSpeed = Math.max(STATE.glowSpeed, 1.0 + STATE.scrollVelocity * 0.2);
          STATE.glowSpeed = Math.min(STATE.glowSpeed, 5.0);  // Cap at 5x
          STATE.glowLinger = 60;  // Frames to linger (about 1 second at 60fps)
        } else if (STATE.glowLinger > 0) {
          // Linger period - keep current speed, just count down
          STATE.glowLinger--;
        } else {
          // Settle back to normal slowly
          STATE.glowSpeed += (1.0 - STATE.glowSpeed) * 0.02;
        }
        
        // Apply speed multiplier to glow time
        heroLogo.userData.glowMaterial.uniforms.uTime.value += 0.016 * STATE.glowSpeed;
        
        // 🔥❄️ FIRE/ICE THEME BLEND based on scroll section
        // Sections: 0=Hero(fire), 1=About(ice), 2=Work(fire), 3=Process(ice), 4=Contact(fire)
        if (scroller) {
          // Use targetSection for immediate response when animation starts
          const section = scroller.targetSection;
          // Target: 0 for fire sections (0, 2, 4), 1 for ice sections (1, 3)
          const targetBlend = (section === 1 || section === 3) ? 1.0 : 0.0;
          
          // Smooth lerp over ~2 seconds to match scroll animation
          const currentBlend = heroLogo.userData.glowMaterial.uniforms.uThemeBlend.value;
          heroLogo.userData.glowMaterial.uniforms.uThemeBlend.value += (targetBlend - currentBlend) * 0.025;
          
          // Toggle status dot color
          const statusDot = document.querySelector('.status-dot');
          if (statusDot) {
            // Remove all state classes first
            statusDot.classList.remove('ice', 'rainbow');
            
            if (section === 4) {
              // Contact section - rainbow
              statusDot.classList.add('rainbow');
            } else if (section === 1 || section === 3) {
              // Ice sections (About, Process)
              statusDot.classList.add('ice');
            }
            // Fire sections (Hero, Work) - no class, uses default orange
          }
        }
      }
      
      // Hero text parallax - slower, it's behind the balls
      // Skip during loading - not visible
      if (!isLoadingMode) {
        heroTextPlane.position.x += (STATE.mouse.x * 0.2 - heroTextPlane.position.x) * 0.02;
        heroTextPlane.position.y += (heroScrollOffset.textY + STATE.mouse.y * 0.15 - heroTextPlane.position.y) * 0.03;
      }
      
      // Animate floating balls - Z depth movement + parallax
      // Skip during loading - not visible
      if (!isLoadingMode) {
        floatingBalls.forEach((ball) => {
          const d = ball.userData;
          const scrollY = d.scrollOffsetY || 0;
          ball.position.z = d.baseZ + Math.sin(time * d.speedZ + d.phase) * d.ampZ;
          ball.rotation.x += d.rotSpeed * 0.01;
          ball.rotation.y += d.rotSpeed * 0.015;
          
          // Mouse parallax - foreground, moves more
          ball.position.x += (d.baseX + STATE.mouse.x * 0.5 - ball.position.x) * 0.04;
          ball.position.y += (d.baseY + scrollY + STATE.mouse.y * 0.35 - ball.position.y) * 0.06;
        });
        
        // Animate floating neurons - similar to balls but for About section
        floatingNeurons.forEach((neuron) => {
          if (!neuron.visible) return;
          const d = neuron.userData;
          neuron.position.z = d.baseZ + Math.sin(time * d.speedZ + d.phase) * d.ampZ;
          neuron.rotation.x += d.rotSpeed * 0.008;
          neuron.rotation.y += d.rotSpeed * 0.012;
          neuron.rotation.z += d.rotSpeed * 0.005;
          
          // Mouse parallax - X and Y
          neuron.position.x += (d.baseX + STATE.mouse.x * 0.4 - neuron.position.x) * 0.05;
          neuron.position.y += (d.baseY + STATE.mouse.y * 0.35 - neuron.position.y) * 0.05;
        });
        
        // Rotate DNA helix - hover spin or auto-rotate
        if (dnaHelix && dnaHelix.visible) {
          if (dnaInteraction.isHovering) {
            // Hovering - apply mouse velocity
            dnaHelix.rotation.y += dnaInteraction.velocityY;
            dnaInteraction.currentAutoSpeed = 0;
          } else {
            // Not hovering - decay momentum, ramp up auto-rotate
            dnaInteraction.velocityY *= 0.96;
            dnaInteraction.currentAutoSpeed += (dnaInteraction.autoRotateSpeed - dnaInteraction.currentAutoSpeed) * 0.02;
            dnaHelix.rotation.y += dnaInteraction.velocityY + dnaInteraction.currentAutoSpeed;
          }
        }
      }
      
      // Only render loader to texture during warp (not during loading mode)
      // During loading, we render loaderScene directly to screen - no need for RT
      if (!isLoadingMode) {
        renderLoaderToTexture();
      }
      
      // Floating animation using base Y positions
      // Skip during loading - models not visible
      if (!isLoadingMode) {
        Object.entries(MODELS).forEach(([name, m], i) => {
          if (m && m.visible) {
            // Never float the logo - gsap controls it completely
            if (name === 'logo') return;
            const baseY = MODEL_BASE_Y[name] || 0;
            m.position.y = baseY + Math.sin(time * 1.5 + i) * 0.03;
          }
        });
      }
      
      // Subtle light movement - skip during loading
      if (!isLoadingMode) {
        blueLight.position.x = -6 + Math.sin(time * 0.5) * 0.3;
        pinkLight.position.x = 6 + Math.cos(time * 0.4) * 0.3;
      }
      
      // Render based on mode
      if (isLoadingMode) {
        // During loading: render loaderScene directly to screen
        renderer.render(loaderScene, loaderCamera);
      } else {
        // Log first time composer kicks in
        if (!loggedComposerStart) {
          loggedComposerStart = true;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // DOF RENDERING - When floating balls, neurons, or process timeline are visible
        // Skip on mobile - fixes WebGL feedback loop and improves performance
        // ═══════════════════════════════════════════════════════════════
        
        // Check if any DOF objects are visible
        const ballsVisible = floatingBalls.some(ball => ball.visible);
        const neuronsVisible = floatingNeurons.some(neuron => neuron.visible);
        
        // Only run expensive blur passes on desktop
        if ((ballsVisible || neuronsVisible) && !isMobile && heavyBlurComposer) {
          // Render small/distant objects with heavy blur (layer 2)
          camera.layers.set(2);
          heavyBlurComposer.render();
          
          // Render medium objects with light blur (layer 1)
          camera.layers.set(1);
          lightBlurComposer.render();
          
          // Render large objects with minimal blur (layer 3)
          camera.layers.set(3);
          minBlurComposer.render();
          
          // Read from EffectComposer's internal readBuffer (proper ping-pong result)
          warpPass.uniforms.tBlurHeavy.value = heavyBlurComposer.readBuffer.texture;
          warpPass.uniforms.tBlurLight.value = lightBlurComposer.readBuffer.texture;
          warpPass.uniforms.tBlurMin.value = minBlurComposer.readBuffer.texture;
        }
        
        // Main render: layer 0 only (everything else)
        camera.layers.set(0);
        
        // During/after warp: use composer with warp effect
        composer.render();
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // CURSOR LOOP - Separate from WebGL so it stays smooth during warp
    // ═══════════════════════════════════════════════════════════════════
    function cursorLoop() {
      requestAnimationFrame(cursorLoop);
      
      // Cursor with trails
      cx += (tx - cx) * 0.4;
      cy += (ty - cy) * 0.4;
      cursor.style.transform = `translate(${cx}px, ${cy}px) translate(-50%, -50%)`;
      
      // Update trails with delay
      for (let i = 0; i < trails.length; i++) {
        trailPositions[i].x += (tx - trailPositions[i].x) * (0.7 - i * 0.1);
        trailPositions[i].y += (ty - trailPositions[i].y) * (0.7 - i * 0.1);
        trails[i].style.transform = `translate(${trailPositions[i].x}px, ${trailPositions[i].y}px) translate(-50%, -50%)`;
        trails[i].style.opacity = i === 0 ? 1 : 0.5 - (i * 0.15);
        trails[i].textContent = chars[(currentCharIndex + i + 1) % chars.length];
      }
    }
    cursorLoop();
    
    animate();
    
    // ═══════════════════════════════════════════════════════════════════
    // RESIZE
    // ═══════════════════════════════════════════════════════════════════
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      
      // Update DOF blur composers and render targets
      heavyBlurRT.setSize(window.innerWidth, window.innerHeight);
      heavyBlurComposer.setSize(window.innerWidth, window.innerHeight);
      hBlurHeavy1.uniforms.h.value = 0.5 / window.innerWidth;
      vBlurHeavy1.uniforms.v.value = 0.5 / window.innerHeight;
      hBlurHeavy2.uniforms.h.value = 0.5 / window.innerWidth;
      vBlurHeavy2.uniforms.v.value = 0.5 / window.innerHeight;
      
      lightBlurRT.setSize(window.innerWidth, window.innerHeight);
      lightBlurComposer.setSize(window.innerWidth, window.innerHeight);
      hBlurLight.uniforms.h.value = 0.7 / window.innerWidth;
      vBlurLight.uniforms.v.value = 0.7 / window.innerHeight;
      
      minBlurRT.setSize(window.innerWidth, window.innerHeight);
      minBlurComposer.setSize(window.innerWidth, window.innerHeight);
      hBlurMin.uniforms.h.value = 0.25 / window.innerWidth;
      vBlurMin.uniforms.v.value = 0.25 / window.innerHeight;
      
      // Update refraction render target
      refractionRT.setSize(window.innerWidth, window.innerHeight);
      refractionUniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
      
      // Update grid resolution
      perspGridMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
      
      // Resize loader camera
      loaderCamera.aspect = window.innerWidth / window.innerHeight;
      loaderCamera.updateProjectionMatrix();
      
      // Update loader canvas size
      updateLoaderCanvasSize();
      drawLoaderGraphics(loaderProgress);
      loaderTexture.needsUpdate = true;
      
      const pixelRatio = Math.min(window.devicePixelRatio, 1.5);
      loaderRT.setSize(
        window.innerWidth * pixelRatio,
        window.innerHeight * pixelRatio
      );
      
      warpPass.uniforms.uAspect.value = window.innerWidth / window.innerHeight;
      ScrollTrigger.refresh();
    });
    
    // Failsafe loader
    setTimeout(() => {
      if (STATE.loaded < STATE.total) {
        STATE.loaded = STATE.total;
        loaderProgress = 1;
        const fill = document.querySelector('.loader-fill');
        if (fill) fill.style.width = '100%';
        setTimeout(() => {
            triggerWarpIntro();
        }, 500);
      }
    }, 5000);
    
  </script>
  
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c1d9a9df92db9fa',t:'MTc2OTA2OTczMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>